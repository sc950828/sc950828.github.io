## webpack 性能优化

性能优化主要包括 webpack 的构建优化和我们打包出来的包的优化

## webpack 构建的速度的优化

### 在 loader 配置里合理的使用 include exclude

我们可以合理的使用 exclude、include 配置来确保转译尽可能少的文件。 exclude 的优先级高于 include。

exclude 和 include 需要是绝对路径。

```js
const path = require("path");
module.exports = {
  //...
  module: {
    rules: [
      {
        test: /\.js[x]?$/,
        use: ["babel-loader"],
        include: [path.resolve(__dirname, "src")],
        exclude: /node_modules/,
      },
    ],
  },
};
```

### plugin

1. plugin 的使用尽可能的精简并确保可靠。
2. 区分开发和生产环境，使 plugin 的应用达到最优。
3. 尽量使用官网插件，官网插件性能更好，第三方的插件性能不能预估，可能会影响 webpack 的构建速度。

### cache-loader

在一些性能开销较大的 loader 之前添加 cache-loader，将结果缓存中磁盘中。默认保存在 node_modueles/.cache/cache-loader 目录下。

```
npm install cache-loader -D
```

```js
module.exports = {
  //...

  module: {
    //我的项目中,babel-loader耗时比较长，所以我给它配置了`cache-loader`
    rules: [
      {
        test: /\.jsx?$/,
        // 第一种使用cache-loader
        // use: ["cache-loader", "babel-loader"],
        // 第二种配置 babel-loader 默认支持的 cacheDirectory
        use: {
          loader: "babel-loader",
          options: {
            cacheDirectory: true,
          },
        },
      },
    ],
  },
};
```

如果你跟我一样，只打算给 babel-loader 配置 cache 的话，也可以不使用 cache-loader，给 babel-loader 增加选项 cacheDirectory。

cacheDirectory：默认值为 false。当有设置时，指定的目录将用来缓存 loader 的执行结果。之后的 Webpack 构建，将会尝试读取缓存，来避免在每次执行时，可能产生的、高性能消耗的 Babel 重新编译过程。设置空值或者 true 的话，使用默认缓存目录：node_modules/.cache/babel-loader。

### DllPlugin DllReferencePlugin

使第三方模块只打包一次，加快我们的打包速度。

把第三方包单独打包，会生成对应的 vendors.dll.js 和 vendors.manifest.json 文件

```js
// webpack.dll.js
const path = require("path");
const webpack = require("webpack");

// 把不变的第三方库单独抽离出来打包 然后关联过去
module.exports = {
  mode: "production",
  entry: {
    vendors: ["react", "react-dom", "lodash"],
  },
  output: {
    filename: "[name].dll.js",
    path: path.resolve(__dirname, "dll"),
    library: "[name]",
  },
  plugins: [
    // 生成 manifest.json 关联关系
    new webpack.DllPlugin({
      name: "[name]",
      path: path.resolve(__dirname, "dll/[name].manifest.json"),
    }),
  ],
};
```

在我们真正的打包文件中引入

```js
plugins: [
  // 将单独打包的文件自动引入到html文件中
  new AddAssetHtmlWebpackPlugin({
    filepath: path.resolve(__dirname, "dll/vendors.dll.js"),
    publicPath: "./",
  }),
  // 关联单独打包的第三方库包
  new wepack.DllReferencePlugin({
    manifest: path.resolve(__dirname, "dll/vendors.manifest.json"),
  }),
];
```

这样第三方包就不会进行重复打包了。

### 使用合理的 devtool

合理的 devtool 配置会生成对应的 source-map，也能提升 webpack 的性能。

### 多进程打包 happypack thread-loader

多进程打包发挥多核 CPU 电脑的威力，以提升构建速度。

每次 webapck 解析一个模块，HappyPack 会将它及它的依赖分配给 worker 线程中。处理完成之后，再将处理好的资源返回给 HappyPack 的主进程，从而加快打包速度。

thread-loader 原理和 HappyPack 类似，也是每次 webpack 解析一个模块，thread-loader 会将它及它的依赖分配给 worker 线程中，从而达到多进程打包的目的。

thread-loader 和 Happypack 我对比了一下，构建时间基本没什么差别。不过 thread-loader 配置起来为简单。

#### happypack

```
npm install happypack -D
```

```js
// happypack的使用
const Happypack = require("happypack");
module.exports = {
  //...
  module: {
    rules: [
      {
        test: /\.js[x]?$/,
        use: "Happypack/loader?id=js",
        include: [path.resolve(__dirname, "src")],
      },
      {
        test: /\.css$/,
        use: "Happypack/loader?id=css",
        include: [
          path.resolve(__dirname, "src"),
          path.resolve(__dirname, "node_modules", "bootstrap", "dist"),
        ],
      },
    ],
  },
  plugins: [
    new Happypack({
      id: "js", //和rule中的id=js对应
      //将之前 rule 中的 loader 在此配置
      use: ["babel-loader"], //必须是数组
      // happypack 默认开启 CPU核数 - 1 个进程，当然，我们也可以传递 threads 给 Happypack。
      threads: 2,
    }),
    new Happypack({
      id: "css", //和rule中的id=css对应
      use: ["style-loader", "css-loader"],
    }),
  ],
};
```

#### thread-loader

```
npm install thread-loader -D
```

```js
// thread-loader
module.exports = {
  module: {
    //我的项目中,babel-loader耗时比较长，所以我给它配置 thread-loader
    rules: [
      {
        test: /\.jsx?$/,
        use: ["thread-loader", "babel-loader"],
      },
    ],
  },
};
```

### noParse

如果一些第三方模块没有 AMD/CommonJS 规范版本，可以使用 noParse 来标识这个模块，这样 Webpack 会引入这些模块，但是不进行转化和解析，从而提升 Webpack 的构建性能 ，例如：jquery 、lodash。

[noParse](http://webpack.html.cn/configuration/module.html) 属性的值是一个正则表达式或者是一个 function。

```js
//webpack.config.js
module.exports = {
  //...
  module: {
    noParse: /jquery|lodash/,
  },
};
```

### IgnorePlugin

webpack 的内置插件，作用是忽略第三方包指定目录。

例如: moment (2.24.0 版本) 会将所有本地化内容和核心功能一起打包，我们就可以使用 IgnorePlugin 在打包时忽略本地化内容。

```js
//webpack.config.js
module.exports = {
  //...
  plugins: [
    //忽略 moment 下的 ./locale 目录
    new webpack.IgnorePlugin(/^\.\/locale$/, /moment$/),
  ],
};
```

在使用的时候，如果我们需要指定语言，那么需要我们手动的去引入语言包，例如，引入中文语言包:

```js
import moment from "moment";
import "moment/locale/zh-cn"; // 手动引入
```

## 包的优化

### 压缩

使用 uglifyjs-webpack-plugin(不支持 ES6 webpack4 以前) 和 terser-webpack-plugin(webpack4 及以后)。

使用 optimize-css-assets-webpack-plugin 插件压缩 css。

使用 image-webpack-loader 帮助我们来实现。它是基于 imagemin 这个 Node 库来实现图片压缩的。

使用 compression-webpack-plugin 插件，把项目打包成 Gzip 文件，加速请求获取时间，提升响应速度。

### Tree Shaking

使用 Tree Shaking 剔除没用到的 js，减小包体积加快渲染速度

css 我们使用 purgecss-webpack-plugin 和 glob 配合可以去除没有用到的 css

### 代码分割 code split

js 配置 optimization 的 splitChunks 能实现代码分割。

css 使用 mini-css-extract-plugin 提取 CSS 代码到单独文件，使用 link 标签加载。

这样将包分为多个文件，减小包体积，浏览器并发加载多个文件，响应速度更快。

### 动态 cdn

配置 extensions 或者使用 html-webpack-externals-plugin 插件

使用 extensions 的话在 html 里面还需要手动引入 cdn，但是使用 html-webpack-externals-plugin 插件的话可以一步到位。

安装

```
npm i  html-webpack-externals-plugin -D
```

```js
new HtmlWebpackExternalsPlugin({
  externals: [
    {
      module: "react",
      entry: "https://unpkg.com/react@16/umd/react.production.min.js",
      global: "React",
    },
    {
      module: "react-dom",
      entry: "https://unpkg.com/react-dom@16/umd/react-dom.production.min.js",
      global: "ReactDOM",
    },
  ],
});
```
