## 浏览器渲染流程

1. 下载解析 HTML 文件，构建 DOM 树。下载解析 CSS 生成 CSSDOM 树。这两个是并行的。
2. CSSDOM 树构建完成与 DOM 树组合形成 RenderObject 树。
3. 根据 render 树布局（Layout），负责各元素尺寸、位置的计算。(涉及到回流)
4. 根据 render 树绘制（paint），绘制页面像素信息。(涉及到重绘)
5. 浏览器会将各层的信息发送给 GUI，GUI 将各层合成（composite），显示在屏幕上。

### 回流(reflow)

又叫重排（layout）。当元素的尺寸、结构、内容变化、浏览器窗口尺寸改变或者触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。

### 重绘(repaint)

当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要 UI 层面的重新像素绘制，因此损耗较少。(改变元素颜色 背景色 visibility)

## 导致回流的操作

1. 添加、删除元素
2. display: none
3. 移动元素位置
4. 修改浏览器大小、字体大小
5. 使用如下 api

```
clientWidth、
clientHeight、
clientTop、
clientLeft、
offsetWidth、
offsetHeight、
offsetTop、
offsetLeft、
scrollWidth、
scrollHeight、
scrollTo、
scrollBy、
scrollTop、
scrollLeft、
getComputedStyle
```

## 减少回流的方法

1. 对于元素的操作尽量只使用 transform 的 translate、scale、rotate 因为 这些 api 不会触发回流和重绘只会触发合成（composite）。
2. opacity 透明度不会触发回流和重绘只会触发合成（composite）。
3. 大规模的新增子 dom 可以先使用 document.createDocumentFragment() 创建，然后一次性插入。
4. 不要频繁读写，批处理 DOM 读/写操作
5. 读写分离

## 防止布局抖动

我们可以使用[fastdom](https://github.com/wilsonpage/fastdom)来防止布局抖动。

原理主要是 通过批处理 DOM 读/写操作消除布局抖动。

```js
// 读写分离
// 读
const read = fastdom.measure(() => {});
// 写
const write = fastdom.mutate(() => {});

fastdom.clear(read);
fastdom.clear(write);
```

## 合成(composite)

将页面拆分图层进行绘制再进行复合
