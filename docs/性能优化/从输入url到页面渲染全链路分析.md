## 步骤

从用户输入域名到浏览器渲染页面的过程，可以分为以下几个步骤：

1. 域名解析
2. 网络请求
3. 服务器处理
4. 浏览器渲染

## 域名解析

DNS 就是域名系统，作用是将域名解析成对应的 IP 地址。具体的解析过程

1. 输入一个 url，首先浏览器会对 url 进行解析，取出主机名
2. 接着查找浏览器自身的 DNS 缓存，查到返回对应 IP
3. 没有找到，在本机找 Host 文件是否有对应的 IP（host 文件就是域名和 ip 的映射关系表），查到就返回 IP
4. 没有的话，本地 DNS 服务器开始查找，向各级的 DNS 服务器（管理方 DNS 服务器、其他 DNS 服务器、顶层 DNS 服务器、根 DNS 服务器）发送查询报文，获取对应的 IP 地址

在每次查找的过程中，浏览器，应用程序，DNS 服务器都会对域名进行缓存，如果命中缓存，DNS 会直接返回对应的 IP，没有命中则继续查找相关的域名服务器，寻找 IP。

分析可知这个阶段，我们能优化的方法有限，常见的做法有：

1. 在 html 文件增加 DNS 缓存标签
2. 通过将域名解析到多个 IP，做 DNS 的负载均衡

```html
<!-- 会预取g.test.com解析 -->
<link rel="dns-prefetch" href="//g.alicdn.com" />

<!-- 自动开启DNS解析功能 -->
<meta http-equiv="x-dns-prefetch-control" content="on" />
```

## 网络请求

### 网络链接

![image](https://xiaosu72.oss-cn-shanghai.aliyuncs.com/blog/images/%E6%9C%AA%E5%91%BD%E5%90%8D1623221100.png)

### http 请求过程

1. 首先如果是第一次请求，域名经过 DNS 服务器解析拿到映射的 IP
2. 这里客户端发送 http 报文给对应的服务器，这个过程中要经过应用层、传输层、网络层、数据链路层和物理层对数据报的层层处理
3. 客户端和服务器（或代理服务器）进行三次握手建立 TCP 连接
4. 然后服务器返回对应的资源给客户端
5. 如果是第二次及以上的请求，浏览器或服务器会通过 http 的 header 参数，判断资源是否过期(这里涉及到强缓存，协商缓存)，如果没有过期，则使用缓存，如果过期，就去服务器拿新的资源

### 五层计算机体系模型

第二步，这里客户端发送 http 报文给对应的服务器，具体的过程为：

1. 首先应用层提供了很多协议，包括：http、ftp、POP3、IMAP，这里浏览器使用的是 http 协议，首先浏览器会在应用层，把请求的数据报按照 http 协议要求的格式，定义一系列请求的字段，推进 TCP 套接字，等待运输层接收。
2. 运输层主要的协议有：TCP 和 UDP，运输层拿到数据报以后，会先看是否和目的主机建立连接，如果没有，则进行三次握手，建立 TCP 连接。如果连接成功，会对数据报进一步封装，增加源主机端口号和目的主机端口号，进行差错检测，然后传递到网络层。
3. 网络层主要协议有：IP 协议，接收运输层的数据报，然后增加目的主机 IP，封装成一段段符合 IP 协议的 IP 数据报，经过若干个路由到达数据链路层
4. 数据链路层有 ARP 协议，可以通过 IP 地址解析目标地址的 mac 地址，通过物理层转发出去，到达目的局域网后，通过广播，被目的主机接收

### 浏览器缓存策略

浏览器的缓存策略，有助于提高网页加载速度，减轻服务器压力。

缓存分为强缓存和协商缓存。

1. 当我们输入 url，浏览器会去查看自身是否有缓存，如果没有缓存会直接请求服务器获取资源，并缓存到浏览器一份，返回数据会携带 ETag 字段和 Last-Modified 字段，状态码 200 OK（from memory cache）,其中 ETag 是文件计算的 hash 值，如果文件不发生改变，这个值不会变。Last-Modified 是文件最后的修改时间，如果文件更新或者覆盖就会显示最新的时间

2. 如果浏览器有缓存，此时检查 http 的请求头，看 cache-control、expires 字段，判断是否过了缓存的有效期，如果没有过有效期，则返回 200 状态码和对应的缓存数据。此时命中的是强缓存。

- 强缓存分为 expires、cache-control 两种，两者同时存在，cache-control 优先级高

- expires 是 http1.0 的定义，服务端返回一个绝对的时间 GMT，为过期时间。这就导致如果服务器时间和浏览器时间不一致，可能会使缓存失效。

- cache-control 是 http1.1 的定义

  - Cache-Control 服务端参数
    - max-age: 在多少秒内有效
    - s-maxage: 就是用于表示 cache 服务器上（比如 cache CDN，缓存代理服务器）的缓存的有效时间的，并只对 public 缓存有效。
    - no-cache：不使用本地强缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在 ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。
    - no-store：直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。
    - public：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。
    - private：只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。默认的。
  - Cache-Control 客户端参数
    - max-stale: 5 表示客户端到代理服务器上拿缓存的时候，即使代理缓存过期了也不要紧，只要过期时间在 5 秒之内，还是可以从代理中获取的。
    - min-fresh: 5 表示代理缓存需要一定的新鲜度，不要等到缓存刚好到期再拿，一定要在到期前 5 秒之前的时间拿，否则拿不到。
    - only-if-cached 这个字段加上后表示客户端只会接受代理缓存，而不会接受源服务器的响应。如果代理缓存无效，则直接返回 504（Gateway Timeout）。

3. 如果浏览器缓存已过期，就携带请求头字段 If-None-Match 和 If-Modified-Since 去服务器拉取资源，服务器看到这两个字段，发现和当前服务器资源一致，就直接返回缓存和状态码 304。服务器一般会先验证 If-None-Match，如果不变，再去验证 If-Modified-Since。此时命中的是协商缓存。

- 协商缓存分为 If-None-Match/ETag 组合、If-Modified-Since/Last-Modified 组合两种，两者同时存在，If-None-Match/ETag 优先级高。ETag 和 Last-Modified 是在响应头中，If-None-Match 和 If-Modified-Since 是在请求头中，值是对应的 ETag 和 Last-Modified 的值。

## 服务器处理阶段

服务器接收到请求，协商缓存查看资源是否有变化，如果没有变化直接返回缓存资源。

这里如果存在代理服务器或者 CDN 节点，那么相当于增加了一个缓存节点，首先请求会转发到最新的 CDN 节点，CDN 节点收到请求后会判断当前资源是否命中协商缓存，如果过期就回源请求最新的资源，如果没有过期就返回缓存资源。

CDN 的存在解决了跨地域请求的时延问题；对服务器压力进行了分流。

四次挥手：如果请求结束，服务器和客户端进行四次挥手，断开连接。

## 页面渲染阶段

![image](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7169ac55453c4138a61c1f733524ff5c~tplv-k3u1fbpfcp-watermark.image)

1. 下载解析 HTML 文件，构建 DOM 树。下载解析 CSS 生成 CSSDOM 树。这两个是并行的。
2. CSSDOM 树构建完成与 DOM 树组合形成 RenderObject 树。
3. 根据 render 树布局（Layout），负责各元素尺寸、位置的计算。(涉及到回流)
4. 根据 render 树绘制（paint），绘制页面像素信息。(涉及到重绘)
5. 浏览器会将各层的信息发送给 GUI，GUI 将各层合成（composite），显示在屏幕上。

## 缓存常见问题

### 强缓存 协商缓存区别？

- 强缓存不会发送请求，返回状态码 200
- 协商缓存会发送请求，返回状态码 304

### 强缓存 协商缓存顺序？

- 先强缓存 Cache-Control expires
- 再协商缓存 Etag Last-Modified

### Etag 是由什么生成的，与另外一种协商缓存的区别是什么?

- Etag 是由 Last-Modified 与 Content-Length 计算而成，etag 与 If-None-Match 一起搭配组成协商缓存，这种协商缓存是下面这种协商缓存的升级版，检测时间的同时还检测文件大小，所以更准确。
- 另外一种协商缓存是 Last-Modified 与 If-Modified-Since 搭配组成的协商缓存，这种缓存只根据时间来计算，所以相对不准确，只能应用于秒级别的修改，如果在一秒内修改，检测不到。
- 在性能上，Etag 要逊于 Last-Modified，毕竟 Last-Modified 只需要记录时间，而 Etag 需要服务器通过算法来计算出文件内容的一个 hash 值。

### 如果 http 响应头中 ETag 值改变了，是否意味着文件内容一定已经更改？

不一定，因为编辑了文件但是并未修改内容时 Last-Modified 的时间也会发生变化，所以 Etag 会重新生成。

### http 服务中静态文件的 Last-Modified 是根据什么生成的？

更新时间
