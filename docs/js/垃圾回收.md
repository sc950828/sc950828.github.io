## 机制

JavaScript 垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是时时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行

## 类型

垃圾回收有两种方法：引用计数、标记清除。

### 引用计数

所谓"引用计数"是指语言引擎有一张"引用表"，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是 0，就表示这个值不再用到了，因此可以将这块内存释放。

引用计数无法解决循环引用的问题，目前主流浏览器使用的是标记清除方案。

### 标记清除

这是 javascript 中最常用的垃圾回收方式。当变量进入执行环境是，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。

垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。

## 哪些情况会引起内存泄漏？

虽然 JavaScript 会自动垃圾收集，但是如果我们的代码写法不当，会让变量一直处于“进入环境”的状态，无法被回收。下面列一下内存泄漏常见的几种情况：

### 意外的全局变量

```js
function foo(arg) {
  bar = "this is a hidden global variable";
}
```

### 被遗忘的计时器或回调函数

```js
var someResource = getData();
setInterval(function() {
    var node = document.getElementById('Node');
    if(node) {
        // 处理 node 和 someResource
        node.innerHTML = JSON.stringify(someResource));
    }
}, 1000);
```

### 闭包

```js
function bindEvent() {
  var obj = document.createElement("xxx");
  obj.onclick = function() {
    // Even if it is a empty function
  };
}
```

### 没有清理的 DOM 元素引用

```js
var elements = {
  button: document.getElementById("button"),
  image: document.getElementById("image"),
  text: document.getElementById("text"),
};

function removeButton() {
  document.body.removeChild(document.getElementById("button"));
  // 此时，仍旧存在一个全局的 #button 的引用
  // elements 字典。button 元素仍旧在内存中，不能被 GC 回收。
}
```

## Chrome V8 垃圾回收

Chrome V8 垃圾回收 分为新生代和老生代算法

### V8 内存限制，在 node 中 javascript 能使用的内存是有限制的.

- 64 位系统下约为 1.4GB。
- 32 位系统下约为 0.7GB。

### V8 为什么会有内存限制

- 表面上的原因是 V8 最初是作为浏览器的 JavaScript 引擎而设计，不太可能遇到大量内存的场景。
- 而深层次的原因则是由于 V8 的垃圾回收机制的限制。由于 V8 需要保证 JavaScript 应用逻辑与垃圾回收器所看到的不一样，V8 在执行垃圾回收时会阻塞 JavaScript 应用逻辑，直到垃圾回收结束再重新执行 JavaScript 应用逻辑，这种行为被称为“全停顿”（stop-the-world）。
- 若 V8 的堆内存为 1.5GB，V8 做一次小的垃圾回收需要 50ms 以上，做一次非增量式的垃圾回收甚至要 1 秒以上。
- 这样浏览器将在 1s 内失去对用户的响应，造成假死现象。如果有动画效果的话，动画的展现也将显著受到影响。

### V8 新生代算法（Scavenge）

新生代中的对象主要通过 Scavenge 算法进行垃圾回收。在 Scavenge 的具体实现中，主要采用 Cheney 算法。

1. Cheney 算法是一种采用复制的方式实现的垃圾回收算法，它将堆内存一分为二，这两个空间中只有一个处于使用中，一个处于闲置状态。
2. 处于使用状态的空间称为 From 空间，处于闲置的空间称为 To 空间。
3. 分配对象时，先是在 From 空间中进行分配，当开始垃圾回收时，会检查 From 空间中的存活对象，并将这些存活对象复制到 To 空间中，而非存活对象占用的空间被释放。
4. 完成复制后，From 空间和 To 空间的角色互换。

简而言之，垃圾回收过程中，就是通过将存活对象在两个空间中进行复制

Scavenge 算法的缺点是只能使用堆内存中的一半，但由于它只复制存活的对象，对于生命周期短的场景存活对象只占少部分，所以在时间效率上有着优异的表现。

#### 晋升

From 空间中存活的对象在复制到 To 空间之前需要进行检查，在一定条件下，需要将存活周期较长的对象直接移动到老生代中，这个过程称为对象晋升。

第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。

第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。

### V8 老生代算法

在老生代中的对象，由于存活对象占比较大，再采用 Scavenge 方式会有两个问题：

- 一个是存活对象就较多，复制存活对象的效率将会降低。
- 另一个依然是浪费一半空间的问题。为此，V8 在老生代中主要采用 Mark-Sweep(标记清除)和 Mark-Compact(标记整理)相结合的方式进行垃圾回收。

#### Mark-Sweep(标记- 清除算法)

这个算法上文有提到过，这里再说一下。

- 与 Scavenge 不同，Mark-Sweep 并不会将内存分为两份，所以不存在浪费一半空间的行为。Mark-Sweep 在标记阶段遍历堆内存中的所有对象，并标记活着的对象，在随后的清除阶段，只清除没有被标记的对象。
- 也就是说，Scavenge 只复制活着的对象，而 Mark-Sweep 只清除死了的对象。活对象在新生代中只占较少部分，死对象在老生代中只占较少部分，这就是两种回收方式都能高效处理的原因。
- 但是这个算法有个比较大的问题是，内存碎片太多。如果出现需要分配一个大内存的情况，由于剩余的碎片空间不足以完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。所以在此基础上提出 Mark-Compact 算法。

#### Mark-Compact(标记-整理算法)

Mark-Compact 在标记完存活对象以后，会将活着的对象向内存空间的一端移动，移动完成后，直接清理掉边界外的所有内存。
