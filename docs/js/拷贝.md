## 数据类型

基本数据类型 数据存储在栈内存中 所以没有深拷贝 浅拷贝一说，可以理解为都是深拷贝

引用数据类型 存储的是该对象在栈中引用，真实的数据存放在堆内存 所以有赋值拷贝 浅拷贝 深拷贝一说。

## 赋值拷贝

赋值拷贝是两个变量指向的是堆中的一块地址，所以修改互相会有影响

```js
var obj = {
  name: "Hanna Ding",
  age: 22,
};
var obj2 = obj;
obj2["c"] = 5;
console.log(obj); //Object {name: "Hanna Ding", age: 22, c: 5}
console.log(obj2); //Object {name: "Hanna Ding", age: 0, c: 5}
//obj和obj2栈中的值是一样的(指向堆中同一内存地址)所以一个改变另外一个也随之改变。原对象中的子对象改变也会随之改变。
```

## 浅拷贝

可以简单的理解为只拷贝第一层，比如数组的 concat、slice，对象的 assign 拷贝

当拷贝的数值是基本数据类型的时候就可以当做是深拷贝，当数值是引用数据类型的时候就是浅拷贝

```js
// 当拷贝的值是基本数据类型的时候是深拷贝
var a = [1, 2, 3, 4];
var b = a.concat();
a[0] = 0;
console.log(a, b);
// a [0, 2, 3, 4]
// b [1, 2, 3, 4]

// 当数值是引用数据类型的时候就是浅拷贝
var a = [1, 2, 3, { name: "randy" }];
var b = a.concat();
a[3].name = "demi";
console.log(a[3], b[3]);
// a[3] {name: 'demi'}
// b[3] {name: 'demi'}

// Object.assign 原理也是一样的
var a = { age: 18, name: "randy", info: { address: "hunan" } };
var b = Object.assign({}, a);
b.age = 24;
b.info.address = "shanghai";
console.log(a, b);
// a
// {
//   age: 18;
//   info: {
//     address: "shanghai";
//   }
//   name: "randy";
// }

// b
// {
//   age: 24;
//   info: {
//     address: "shanghai";
//   }
//   name: "randy";
// }
```

## 深拷贝

深拷贝是可以完美的解决浅拷贝的弊端，重新开辟一块地址，深拷贝出来的属性的基本类型值都是相同的。

对象的深拷贝可以使用 `JSON.stringify` 和 `JSON.parse`

```js
var a = { age: 18, name: "randy", info: { address: "hunan" } };
var b = JSON.parse(JSON.stringify(a));
b.age = 24;
b.info.address = "shanghai";
console.log(a, b);
```

或者可以自己写深拷贝方法或者借助 lodash 库

使用 `JSON.stringify` 和 `JSON.parse`注意

1. 对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。
2. undefined、任意的函数以及 symbol 值，在序列化过程中会被忽略
3. RegExp、Error 对象，则序列化的结果将只得到空对象。
4. NaN 和 Infinity 格式的数值及 null 都会被当做 null。
5. Date 日期调用了 toJSON() 将其转换为了 string 字符串（同 Date.toISOString()）
