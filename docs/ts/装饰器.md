## 定义

装饰器(decorator)它的主要作用是给一个已有的方法或类扩展一些新的行为，而不是去直接修改它本身。装饰器本质上是一个函数。

## 注意

在 JavaScript 中我们需要 Babel 插件 babel-plugin-transform-decorators-legacy 来支持 decorator,而在 Typescript 中我们需要在 tsconfig.json 里面开启支持选项 experimentalDecorators.

当有多个装饰器的时候，装饰器执行的顺序从下到上 decorator2 decorator1

## 类装饰器

当装饰器作为修饰类的时候，会把构造器传递进去。

```ts
function addAge(constructor: Function) {
  constructor.prototype.age = 18;
}

@addAge
class Person1 {
  name: string;
  age!: number;
  constructor() {
    this.name = "xiaomuzhu";
  }
}

let person = new Person1();

console.log(person.age); // 18
```

## 方法装饰器

1. 普通函数的装饰器接收的参数第一个是类的原型第二个是方法名第三个是修饰符
2. static 函数的装饰器接收的参数第一个是类的构造函数第二个是方法名第三个是修饰符
3. 函数的装饰器运行是在类初始化的时候

```ts
// 声明装饰器修饰方法/属性
function method(
  target: any,
  propertyKey: string,
  descriptor: PropertyDescriptor
) {
  console.log(target);
  console.log("prop " + propertyKey);
  console.log("desc " + JSON.stringify(descriptor) + "\n\n");
  descriptor.writable = false;
}

class Person2 {
  name: string;
  constructor() {
    this.name = "xiaomuzhu";
  }

  @method
  say() {
    return "instance method";
  }

  @method
  static run() {
    return "static method";
  }
}

const xmz = new Person2();

console.log(xmz.say());

// 输出
// { say: [Function (anonymous)] }
// prop say
// desc {"writable":true,"enumerable":true,"configurable":true}

// [Function: Person2] { run: [Function (anonymous)] }
// prop run
// desc {"writable":true,"enumerable":true,"configurable":true}

// instance method
```

## 属性装饰器

1. 属性的装饰器接收的参数第一个是类的原型第二个是属性名
2. 属性的装饰器运行是在类初始化的时候

```ts
function decorator(target: any, key: string): any {
  const descriptor: PropertyDescriptor = {
    writable: false,
  };

  return descriptor;
}

class Test {
  @decorator
  name: string;
}

const test = new Test();
test.name = "randy"; // 报错 不能重新赋值
```

## 访问器的装饰器

1. 访问器的装饰器接收的参数第一个是类的原型第二个是方法名第三个是修饰符
2. 访问器的装饰器运行是在类初始化的时候

```ts
function decorator(target: any, key: string, descriptor: PropertyDescriptor) {
  // 该方法不能被重写
  descriptor.writable = false;
}

class Test {
  private _name: string;

  constructor(name: string) {
    this._name = name;
  }

  get name() {
    return this._name;
  }

  @decorator1
  set name(name: string) {
    this._name = name;
  }
}

const test = new Test("randy");
test.name = "randy2"; // 报错
```

## 函数参数装饰器

1. 参数的装饰器接收的参数第一个是类的原型第二个是方法名第三个参数时参数在函数参数列表里的位置
2. 参数的装饰器运行是在类初始化的时候

```ts
function decrator(target: any, key: string, paramIndex: number) {
  console.log(paramIndex); // 0
}

class Test {
  getName(@decrator name: string) {
    return name;
  }
}
```

## 装饰器传参

```ts
function decorator1(flag: boolean) {
  if (flag) {
    return (constructor: any) => {
      console.log("decorator1");
      constructor.prototype.getName = function () {
        console.log("randy");
      };
    };
  } else {
    return (constructor: any) => {};
  }
}

// 使用 传参
@decorator1(true)
class Test {}

const t1 = new Test(); // decorator1
```
