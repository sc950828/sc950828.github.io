---
theme: channing-cyan
highlight: a11y-dark
---

## 简介

在我们日常开发中偶尔会碰到获取元素样式、设置某元素样式、计算元素位置、计算滚动距离等需求。但是 js 中关于元素位置、样式、大小的 api 种类繁多，稍不留神就会搞不清楚。今天笔者就带你彻底弄清楚，让你在这类问题上不再迷茫。

本文分元素样式的获取和设置、元素位置大小计算、屏幕和窗口位置大小计算三部分来讲解，读完本文你将会学会

1. 元素样式的获取的各种方法以及区别，在哪种情况是使用哪种方式最合适。
2. 元素大小位置计算，弄懂了`client`、`scroll`、`offset`三类 api 的区别。
3. `screen、window`对象关于位置、大小 api，以及各自的区别。

## 元素样式的获取和设置

`ele.style`、`getComputedStyle` 用来获取和设置元素样式。`el.className、el.classList` 用来获取和设置元素类名。`getBoundingClientRect`用来获取元素的位置和大小。

### ele.style

通过获取元素的`style`属性来获取元素样式。

#### 语法

```html
<head>
  <style>
    .div1 {
      color: red;
    }
  </style>
</head>

<div id="div1" class="div1" style="font-size: 18px">style测试</div>
```

```js
const div1 = document.querySelector("#div1");
console.log(div1.style.fontSize); // 18px
console.log(div1.style.color); // 获取不到该样式
```

#### 特点

1. 这种方式获取的样式属性值是驼峰式。
2. 这种方式只能获取到元素的内联样式。
3. 我们可以通过该方法设置元素样式。

#### 常用方法

**cssText**

我们还可以使用`cssText`来获取样式的字符串。

```js
console.log(div1.style.cssText); // font-size: 18px;
```

**setProperty**

我们可以使用`setProperty`方法来设置元素样式。

注意我们设置元素样式的属性不是驼峰式写法。

```js
div1.style.setProperty("font-weight", 600);
console.log(div1.style.fontWeight); // 600

// 当然这种方式也是可以的
div1.style.fontWeight = 600;
console.log(div1.style.fontWeight); // 600
```

**getPropertyValue**

我们可以使用`getPropertyValue`方法来获取元素样式。

注意我们获取元素样式的属性不是驼峰式写法。

```js
div1.style.getPropertyValue("font-size"); // 18px

// 当然这种方式也是可以的
console.log(div1.style.fontSize);
```

**removeProperty**

我们可以使用`removeProperty`方法来移除元素某样式。

```js
div1.style.removeProperty("font-weight");

// 当然这种方式也是可以的
div1.style.fontWeight = "";
```

### getComputedStyle(ele)

该方法挂载在`window`对象下，我们使用的时候可以省略`window`。

#### 语法

```html
<head>
  <style>
    .div1 {
      color: red;
    }
  </style>
</head>

<div id="div1" class="div1" style="font-size: 18px">style测试</div>
```

```js
const div1 = document.querySelector("#div1");
console.log(getComputedStyle(div1).fontSize); // 18px
console.log(getComputedStyle(div1).color); // rgb(255, 0, 0)
```

#### 特点

1. 这种方式获取的样式属性值是驼峰式。
2. 能获取元素渲染后的所有样式包括内联和不内联样式。
3. 只能获取元素的样式不能设置元素的样式。

### ele.getBoundingClientRect()

该方法能获取元素的长度和宽度（width、height）。并且能获取元素相对于浏览器窗口的位置信息（left、right、top、bottom）。

#### 语法

```html
<head>
  <style>
    .div1 {
      color: red;
    }
  </style>
</head>

<div id="div1" class="div1" style="font-size: 18px">style测试</div>
```

```js
const div1 = document.querySelector("#div1");

// bottom: 33 盒子下边框距离视口顶部的距离
// height: 25 盒子高度
// left: 8 盒子左边框距离视口左部的距离
// right: 342 盒子右边框距离视口左部的距离
// top: 8 盒子上边框距离视口顶部的距离
// width: 334 盒子的宽度
// x: 8 盒子左上角相对于视口左侧的距离
// y: 8 盒子左上角相对于视口顶部的距离

console.log(div1.getBoundingClientRect());
```

#### 特点

1. 该方法只能获取元素位置和大小信息，不能获取到其他样式信息。
2. 该方法不能设置元素样式。

### el.className、el.classList

除了前面介绍的获取样式，我们还可以获取到类名，然后通过添加类名的方式给元素添加新的样式。

#### 语法

```js
console.log(div1.classList.value); // div1
console.log(div1.className); // div1
div1.className += " div2"; // 添加新类名 div2
```

#### 特点

1. `el.className`获取的是元素的类名字符串，我们可以使用该方法获取类名或者添加新的类名。
2. `el.classList.value`获取的是类名字符串，如果单纯的想获取类名可以使用该方法。

### 总结

1. 当我们需要设置某元素样式的时候我们可以使用`ele.style`方法。
2. 当我们需要获取元素渲染后的所有样式的时候我们可以使用`getComputedStyle(ele)`方法。
3. 当我们需要获取类名或者批量设置元素样式的时候可以使用第三种方法。
4. 当我们需要计算元素位置，或者计算元素是否在可视窗口内或者元素大小的时候我们可以使用`ele.getBoundingClientRect()`方法。

> 有了上面获取元素样式的基础下面我们再来介绍一些元素位置、大小的 api

## 元素位置、大小计算

关于元素位置大小计算主要有`client`、`scroll`、`offset`三类`api`。

### client

`client`可以简单理解为元素可视大小。

#### clientWidth、clientHeight

`clientWidth` 为可视宽度，宽度包含内边距（padding）。不包含边框（border）、外边距（margin）、滚动条。

`clientHeight` 为可视高度，高度包含内边距（padding）。不包含边框（border）、外边距（margin）、滚动条。

#### clientTop、clientLeft

`clientTop`获取的是元素上边框的高度。

`clientLeft`获取的是元素左边框的宽度。

![WX20220310-101109.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/122d9b93070d491982a717ff9c2d4d6c~tplv-k3u1fbpfcp-watermark.image?)

参看上面的例子

1. `clientWidth` 为 `400px - 滚动条15px + 左右内边距20 = 405px`
2. `clientHeight` 为 `200px - 滚动条15px + 上下内边距20 = 205px`
3. `clientTop`为上边框高度`10px`
4. `clientLeft`为左边框宽度`10px`

### scroll

`scroll`可以简单理解为元素实际大小（可滚动大小）。

#### scrollWidth、scrollHeight

`scrollWidth`当元素没滚动条的时候和`clientWidth`一样，为可视宽度。当有滚动条的时候为可滚动的宽度。

`scrollHeight`当元素没滚动条的时候和`clientHeight`一样，为可视高度。当有滚动条的时候为可滚动的高度。

#### scrollTop、scrollLeft

`scrollTop`获取的是元素在 y 轴上滚动的距离。

`scrollLeft`获取的是元素在 x 轴上滚动的近距离。

![WX20220310-102331.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c1da5451fad48adb1a2c16798c44a49~tplv-k3u1fbpfcp-watermark.image?)

参看上面的例子，我们在这里使用了`box1.scrollBy(20, 10);`模拟滚动。

1. `scrollWidth` 为 `600px + 左右内边距20 = 620px`
2. `scrollHeight` 为 `500px + 上下内边距20 = 520px`
3. `clientTop` 为在 y 轴上滚动的距离`10px`
4. `clientLeft` 为在 x 轴上滚动的近距离`20px`

### offset

`offset`可以简单理解为元素占据大小（在文档中的占据空间大小）。

#### offsetWidth、offsetHeight

`offsetWidth` 宽度包含内边距（padding）、边框（border）、滚动条。不包含外边距（margin）。

`offsetHeight` 高度包含内边距（padding）、边框（border）、滚动条。不包含外边距（margin）。

#### offsetParent

`offsetParent`是一个只读属性，获得元素最近祖先元素。没找到就返回`body`元素，用于`offsetLeft`和`offsetTop`的计算。

#### offsetLeft、offseTop

`offsetLeft`相对`offsetParent`水平偏移距离。

`offseTop`相对`offsetParent`垂直偏移距离。

参看上面的例子

![WX20220310-103646.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7af6c479156043ffb31305d7220a46bd~tplv-k3u1fbpfcp-watermark.image?)

1. `offsetWidth` 为 `400px - 滚动条15px + 滚动条15px + 左右内边距20 + 左右边框宽度20px = 440px`
2. `offsetHeight` 为 `200px - 滚动条15px + 滚动条15px + 上下内边距20 + 上下边框宽度20px = 240px`
3. `offsetParent` 因为外面没包裹其他元素，所以直接返回`body`元素。
4. `offsetTop` 因为`margin`为`20px`所以相对于`body`垂直偏移距离为`20px`
5. `offsetLeft` 因为`margin`为`20px`所以相对于`body`水平偏移距离为`20px`

## 屏幕和窗口位置、大小计算

### screen

屏幕相关属性的获取。

#### width、height

这里 `screen.width、screen.height`获取的是电脑屏幕的宽度和高度，跟我们浏览器大小是无关的。

#### availWidth、availHeight

这里 `screen.availWidth、screen.availHeight`获取的是电脑屏幕的实际宽度和实际高度，如果有任务栏是需要去掉的。跟我们浏览器大小是无关的。

### window

浏览器窗口相关属性的获取。

#### outerWidth、outerHeight

`outerWidth`返回的是浏览器整个的宽度，如果浏览器最大化的话和`screen.availWidth`值相等。

`outerHeight`返回的是浏览器整个的高度，如果浏览器最大化的话和`screen.availHeight`值相等。

#### innerWidth、innerHeight

`innerWidth`返回的是浏览器文档可视的宽度，只包括滚动条。

`innerHeight`返回的是浏览器文档可视的高度，只包括滚动条，不包括顶部的 tab、和书签栏。

#### screenX、screenLeft

`window.screenX、window.screenLeft`获取的是浏览器窗口左上角相对于屏幕左边框的距离。

ie 不支持`window.screenX`火狐不支持`window.screenLeft`

#### screenY、screenTop

`window.screenY、window.screenTop`获取的是浏览器窗口左上角相对于屏幕上边框的距离。

ie 不支持`window.screenY`火狐不支持`window.screenTop`

#### scrollX、scrollY

`window.scrollX`返回的是窗口在 x 轴上滚动的距离。

`window.scrollY`返回的是窗口在 y 轴上滚动的距离。

#### pageXOffset、pageYOffset

`window.pageXOffset`返回的是窗口在 x 轴上滚动的距离。

`window.pageYOffset`返回的是窗口在 y 轴上滚动的距离。

注意：

> 这里`scrollX、scrollY、pageXOffset、pageYOffset`需要和上面的`scrollTop`、`scrollLeft`区分，这四个`api`只在`window`对象上有。

> 相对于`scrollX`、`scrollY`，`pageXOffset`、`pageYOffset`兼容性更好，一般我们只用  `pageXOffset`、`pageYOffset`就行了。但两者都不兼容 IE9 以下。

## 扩展

有了上面的学习，下面我们来实现几个在日常开发中常见的小需求。

### 获取当前页面的滚动位置

```js
const getScrollPosition = (el = window) => ({
  x: el.pageXOffset !== undefined ? el.pageXOffset : el.scrollLeft,
  y: el.pageYOffset !== undefined ? el.pageYOffset : el.scrollTop,
});

console.log(getScrollPosition()); // {x: 0, y: 200}
```

### 检测页面是否滚动到页面底部

`document.documentElement`获取的是根元素`html`。

```js
const bottomVisible = () =>
  document.documentElement.clientHeight + window.pageYOffset >=
  (document.documentElement.scrollHeight ||
    document.documentElement.clientHeight);

console.log(bottomVisible()); // true
```

### 检查指定的元素在视口中是否全部可见

```js
const elementIsVisibleInViewport = (el) => {
  const { top, left, bottom, right } = el.getBoundingClientRect();
  const { innerHeight, innerWidth } = window;
  return top >= 0 && left >= 0 && bottom <= innerHeight && right <= innerWidth;
};

console.log(elementIsVisibleInViewport(el));
```

## 后记

感谢小伙伴们的耐心观看，本文为笔者个人学习笔记，如有谬误，还请告知，万分感谢！如果本文对你有所帮助，还请点个关注点个赞~，您的支持是笔者不断更新的动力！
