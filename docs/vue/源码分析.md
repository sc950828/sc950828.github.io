## 初始化

在 new Vue() 之后。 Vue 会调用 `_init` 函数进行初始化，也就是这里的 init 过程，它会初始化生命周期、事件、渲染、 props、 methods、 data、 computed 与 watch 等，然后触发 beforeCreate 和 created 生命周期方法。其中最重要的是通过 Object.defineProperty 设置 setter 与 getter 函数，用来实现「响应式」以及「依赖收集」。

```
initLifecycle(vm)
initEvents(vm)
initRender(vm)
callHook(vm, 'beforeCreate')
initInjections(vm) // resolve injections before data/props
initState(vm) // props、 methods、 data、 computed 与 watch 等初始化
initProvide(vm) // resolve provide after data/props
callHook(vm, 'created')
```

初始化之后调用 `$mount` 会挂载组件，如果是运行时编译，即不存在 render function 但是存在 template 的情况，需要进行「编译」步骤。

```js
if (vm.$options.el) {
  vm.$mount(vm.$options.el);
}
```

## 编译

compile 编译可以分成 parse、optimize 与 generate 三个阶段，最终需要得到 render function。

### parse

parse 会用正则等方式解析 template 模板中的指令、class、style 等数据，形成 AST。

### optimize

optimize 的主要作用是标记 static 静态节点，这是 Vue 在编译过程中的一处优化，后面当 update 更新界面时，会有一个 patch 的过程， diff 算法会直接跳过静态节点，从而减少了比较的过程，优化了 patch 的性能。

经过 optimize 这层的处理，每个节点会加上 static 属性，用来标记是否是静态的。

### generate

generate 是将 AST 转化成 render function 字符串的过程，得到结果是 render 的字符串以及 staticRenderFns 字符串。

在经历过 parse、optimize 与 generate 这三个阶段以后，组件中就会存在渲染 VNode 所需的 render function 了。

我们平时使用的 vue-cli 创建的 vue 项目，编译过程其实是在 webpack 构建的过程就已经通过 vue-loader 处理好了。

## 挂载

`$mount` 方法实际上会去调用 mountComponent 方法，mountComponent 核心就是先实例化一个渲染 Watcher，在它的回调函数中会调用 updateComponent 方法，在此方法中调用 `vm._render` 方法通过 render function 先生成虚拟 Node，最终调用 `vm._update` 把虚拟 DOM 更新成 HTML DOM。

### render 把渲染函数变为虚拟 DOM

`vm._render` 最终是通过执行 createElement 方法并返回的是 vnode，它是一个虚拟 Node。Vue 2.0 相比 Vue 1.0 最大的升级就是利用了 Virtual DOM。因此在分析 createElement 的实现前，我们先了解一下 Virtual DOM 的概念。

#### 虚拟 DOM

Virtual DOM 就是用一个原生的 JS 对象去描述一个 DOM 节点，所以它比创建一个 DOM 的代价要小很多，性能更好。在 Vue.js 中，Virtual DOM 是用 VNode 这么一个 Class 去描述。

由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。

```js
{
  tag: 'div',                 /*说明这是一个div标签*/
  children: [                 /*存放该标签的子节点*/
    {
      tag: 'a',           /*说明这是一个a标签*/
      text: 'click me'    /*标签的内容*/
    }
  ]
}
```

### update 把虚拟 DOM 变为 HTML DOM

Vue 的 `_update` 是实例的一个私有方法，它被调用的时机有 2 个，一个是首次渲染，一个是数据更新的时候。`_update` 方法的作用是把 VNode 渲染成真实的 DOM。

映射到真实的 DOM 实际上要经历 VNode 的 create、diff、patch 等过程。

#### patch

patch 的核心 diff 算法，我们用 diff 算法可以比对出两颗树的「差异」。

diff 算法是通过同层的树节点进行比较而非对树进行逐层搜索遍历的方式，所以时间复杂度只有 O(n)，是一种相当高效的算法。

```js
// 因为 patch 的主要功能是比对两个 VNode 节点，将「差异」更新到视图上，
// 所以入参有新老两个 VNode 以及父节点的 element 。
function patch(oldVnode, vnode, parentElm) {
  if (!oldVnode) {
    // 没有老节点 直接用 addVnodes 将这些节点批量添加到 parentElm 上
    addVnodes(parentElm, null, vnode, 0, vnode.length - 1);
  } else if (!vnode) {
    // 没有新节点 相当于要把老的节点删除，所以直接使用 removeVnodes 进行批量的节点删除即可。
    removeVnodes(parentElm, oldVnode, 0, oldVnode.length - 1);
  } else {
    // 当 oldVNode 与 vnode 都存在的时候，需要判断它们是否属于 sameVnode（相同的节点）
    if (sameVnode(oldVNode, vnode)) {
      // 如果是则进行patchVnode（比对 VNode ）操作，否则删除老节点，增加新节点。
      patchVnode(oldVNode, vnode);
    } else {
      // 否则删除老节点，增加新节点
      removeVnodes(parentElm, oldVnode, 0, oldVnode.length - 1);
      addVnodes(parentElm, null, vnode, 0, vnode.length - 1);
    }
  }
}
```

#### sameVnode

sameVnode 其实很简单，只有当 key、 tag、 isComment（是否为注释节点）相同、 data 同时定义（或不定义），同时满足当标签类型为 input 的时候 type 相同（某些浏览器不支持动态修改`<input>`类型，所以他们被视为不同类型）即可。

```js
function sameVnode() {
  return (
    a.key === b.key &&
    a.tag === b.tag &&
    a.isComment === b.isComment &&
    !!a.data === !!b.data &&
    sameInputType(a, b)
  );
}

function sameInputType(a, b) {
  if (a.tag !== "input") return true;
  let i;
  const typeA = (i = a.data) && (i = i.attrs) && i.type;
  const typeB = (i = b.data) && (i = i.attrs) && i.type;
  return typeA === typeB;
}
```

#### patchVnode

```js
function patchVnode(oldVnode, vnode) {
  // 新老 VNode 节点相同的情况下，就不需要做任何改变了，直接 return 掉。
  if (oldVnode === vnode) {
    return;
  }

  // 在当新老 VNode 节点都是 isStatic（静态的），并且 key 相同时，只要将 componentInstance 与 elm 从老 VNode 节点“拿过来”即可。
  if (vnode.isStatic && oldVnode.isStatic && vnode.key === oldVnode.key) {
    vnode.elm = oldVnode.elm;
    vnode.componentInstance = oldVnode.componentInstance;
    return;
  }

  const elm = (vnode.elm = oldVnode.elm);
  // 老节点的子元素
  const oldCh = oldVnode.children;
  // 新节点的子元素
  const ch = vnode.children;

  if (vnode.text) {
    // 当新 VNode 节点是文本节点的时候，直接用 setTextContent 来设置 text
    nodeOps.setTextContent(elm, vnode.text);
  } else {
    if (oldCh && ch && oldCh !== ch) {
      // oldCh 与 ch 都存在且不相同时，使用 updateChildren 函数来更新子节点
      updateChildren(elm, oldCh, ch);
    } else if (ch) {
      // 如果只有 ch 存在的时候，如果老节点是文本节点则先将节点的文本清除，然后将 ch 批量插入插入到节点elm下。
      if (oldVnode.text) nodeOps.setTextContent(elm, "");
      addVnodes(elm, null, ch, 0, ch.length - 1);
    } else if (oldCh) {
      // 同理当只有 oldch 存在时，说明需要将老节点通过 removeVnodes 全部清除
      removeVnodes(elm, oldCh, 0, oldCh.length - 1);
    } else if (oldVnode.text) {
      // 只有老节点是文本节点的时候，清除其节点文本内容。
      nodeOps.setTextContent(elm, "");
    }
  }
}
```

#### updateChildren

首先我们定义 oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 分别是新老两个 VNode 的两边的索引，同时 oldStartVnode、newStartVnode、oldEndVnode 以及 newEndVnode 分别指向这几个索引对应的 VNode 节点。

接下来是一个 while 循环，在这过程中，oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 会逐渐向中间靠拢。

首先当 oldStartVnode 或者 oldEndVnode 不存在的时候，oldStartIdx 与 oldEndIdx 继续向中间靠拢，并更新对应的 oldStartVnode 与 oldEndVnode 的指向

```js
if (!oldStartVnode) {
  oldStartVnode = oldCh[++oldStartIdx];
} else if (!oldEndVnode) {
  oldEndVnode = oldCh[--oldEndIdx];
}
```

接下来这一块，是将 oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 两两比对的过程，一共会出现 `2*2=4` 种情况。

```js
// 首先是 oldStartVnode 与 newStartVnode 符合 sameVnode 时，
// 说明老 VNode 节点的头部与新 VNode 节点的头部是相同的 VNode 节点，
// 直接进行 patchVnode，同时 oldStartIdx 与 newStartIdx 向后移动一位。
 else if (sameVnode(oldStartVnode, newStartVnode)) {
    patchVnode(oldStartVnode, newStartVnode);
    oldStartVnode = oldCh[++oldStartIdx];
    newStartVnode = newCh[++newStartIdx];
// 其次是 oldEndVnode 与 newEndVnode 符合 sameVnode，
// 也就是两个 VNode 的结尾是相同的 VNode，同样进行 patchVnode 操作
// 并将 oldEndVnode 与 newEndVnode 向前移动一位。
} else if (sameVnode(oldEndVnode, newEndVnode)) {
    patchVnode(oldEndVnode, newEndVnode);
    oldEndVnode = oldCh[--oldEndIdx];
    newEndVnode = newCh[--newEndIdx];

// 先是 oldStartVnode 与 newEndVnode 符合 sameVnode 的时候，
// 也就是老 VNode 节点的头部与新 VNode 节点的尾部是同一节点的时候，
// 将 oldStartVnode.elm 这个节点直接移动到 oldEndVnode.elm 这个节点的后面即可。
// 然后 oldStartIdx 向后移动一位，newEndIdx 向前移动一位。
} else if (sameVnode(oldStartVnode, newEndVnode)) {
    patchVnode(oldStartVnode, newEndVnode);
    nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
    oldStartVnode = oldCh[++oldStartIdx];
    newEndVnode = newCh[--newEndIdx];
// oldEndVnode 与 newStartVnode 符合 sameVnode 时，
// 也就是老 VNode 节点的尾部与新 VNode 节点的头部是同一节点的时候，
// 将 oldEndVnode.elm 插入到 oldStartVnode.elm 前面。
// 同样的，oldEndIdx 向前移动一位，newStartIdx 向后移动一位。
} else if (sameVnode(oldEndVnode, newStartVnode)) {
    patchVnode(oldEndVnode, newStartVnode);
    nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
    oldEndVnode = oldCh[--oldEndIdx];
    newStartVnode = newCh[++newStartIdx];
}
```

最后是当以上情况都不符合的时候，createKeyToOldIdx 的作用是产生 key 与 index 索引对应的一个 map 表。

```js
{
  key0: 0,
  key1: 1,
  key2: 2
}
```

通过这个 key，我们的 diff 操作可以更准确、更快速（map 查找比遍历高效）。

我们可以根据某一个 key 的值，快速地从 oldKeyToIdx（createKeyToOldIdx 的返回值）中获取相同 key 的节点的索引 idxInOld，然后找到相同的节点。

如果找到了节点，同时它符合 sameVnode，则将这两个节点进行 patchVnode，将该位置的老节点赋值 undefined（之后如果还有新节点与该节点 key 相同可以检测出来提示已有重复的 key ），同时将 newStartVnode.elm 插入到 oldStartVnode.elm 的前面。同理，newStartIdx 往后移动一位。如果不符合 sameVnode，只能创建一个新节点插入到 parentElm 的子节点中，newStartIdx 往后移动一位。

如果没有找到相同的节点，则通过 createElm 创建一个新节点，并将 newStartIdx 向后移动一位。

最后一步就很容易啦，当 while 循环结束以后，如果 oldStartIdx > oldEndIdx，说明老节点比对完了，但是新节点还有多的，需要将新节点插入到真实 DOM 中去，调用 addVnodes 将这些节点插入即可。

同理，如果满足 newStartIdx > newEndIdx 条件，说明新节点比对完了，老节点还有多，将这些无用的老节点通过 removeVnodes 批量删除即可。

#### 为什么不推荐使用 index 作为 key

如果循环的列表不涉及到增加删除，这样不会有什么性能问题。但是如果设计到增加删除，每次操作会把每个元素的 key 改变了，于是就有了上面对比错位，导致 diff 以为每个 li 都发生了改变，于是页面重新渲染了所有的列表项。归根结底就是因为 key 是动态的不是唯一固定的，导致 diff 算法不准确。

## 响应式系统

vue2 主要是通过 递归遍历 data 对象，使用 Object.defineProperty 方法重写属性的 get、set 方法来实现响应式系统的。它使得当被设置的对象被读取的时候会执行 getter 函数，而在当被赋值的时候会执行 setter 函数。

但是值是 Array 的类型侦测就比较麻烦一些，需要通过重写 Array 原型上的 push,pop,shift,unshift,splice,sort,reverse 的方法来实现侦测。对数组元素是通过遍历，对里面的每一项都调用 observe 方法，进行深度观测。

### 订阅者 Dep

首先我们来实现一个订阅者 Dep ，它的主要作用是用来存放 Watcher 观察者对象。

```js
class Dep {
  constructor() {
    /* 用来存放Watcher对象的数组 */
    this.subs = [];
  }

  /* 在subs中添加一个Watcher对象 */
  addSub(sub) {
    this.subs.push(sub);
  }

  /* 通知所有Watcher对象更新视图 */
  notify() {
    this.subs.forEach((sub) => {
      sub.update();
    });
  }
}
```

1. 用 addSub 方法可以在目前的 Dep 对象中增加一个 Watcher 的订阅操作；
2. 用 notify 方法通知目前 Dep 对象的 subs 中的所有 Watcher 对象触发更新操作。

### 观察者 Watcher

```js
class Watcher {
  constructor() {
    /* 在new一个Watcher对象时将该对象赋值给Dep.target，在get中会用到 */
    Dep.target = this;
  }

  /* 更新视图的方法 */
  update() {
    console.log("视图更新啦～");
  }
}

Dep.target = null;
```

### 依赖收集

我们在闭包中增加了一个 Dep 类的对象，用来收集 Watcher 对象。在对象被「读」的时候，会触发 reactiveGetter 函数把当前的 Watcher 对象（存放在 Dep.target 中）收集到 Dep 类中去。之后如果当该对象被「写」的时候，则会触发 reactiveSetter 方法，通知 Dep 类调用 notify 来触发所有 Watcher 对象的 update 方法更新对应视图。

```js
function defineReactive(obj, key, val) {
  /* 一个Dep类对象 */
  const dep = new Dep();

  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      /* 将Dep.target（即当前的Watcher对象存入dep的subs中） */
      dep.addSub(Dep.target);
      return val;
    },
    set: function reactiveSetter(newVal) {
      if (newVal === val) return;
      /* 在set的时候触发dep的notify来通知所有的Watcher对象更新视图 */
      dep.notify();
    },
  });
}

class Vue {
  constructor(options) {
    this._data = options.data;
    observer(this._data);
    /* 新建一个Watcher观察者对象，这时候Dep.target会指向这个Watcher对象 */
    new Watcher();
    /* 在这里模拟render的过程，为了触发test属性的get函数 进行依赖收集 */
    console.log("render~", this._data.test);
  }
}
```

## `this.$set()`具体是怎么做的？

```js
this.$set(target, key, val);
```

1. target 如果是数组的话,先判断 key 是不是合法的下标,如果这两个条件都通过.那就将 target.length 和传进来的 key 取一个最大值赋值给 target.length,然后调用 splice 去修改数组。
2. key 已经存在 target 里面并且不是存在 target 原型上的,那就是只改变值
3. target 如果不是响应式数据,那么也只是改变数据,不需要通知 watcher
4. 如果 target 是 vue 实例,或者 target 是 `this.$data`,那么直接退出程序
5. 如果上面的条件都不满足,那么就是新添加的响应数据,那就直接调用 defineReactive()去侦测该数据,然后去通知 watcher

## `this.$delete`具体是怎么做的？

```js
this.delete(target, key);
```

1. target 如果是数组的话并且 key 是合法的,那就通过 splice 去改变数组
2. target 如果是 vue 实例.或者是 `this.$data`,那就直接退出程序
3. target 如果不是双向绑定数据,那就直接 delete 就行不需要,通知 watcher
4. 以上条件都不满足,那么 target 就是双向绑定数据,delete 之后通知 watcher
