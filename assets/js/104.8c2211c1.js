(window.webpackJsonp=window.webpackJsonp||[]).push([[104],{459:function(v,_,a){"use strict";a.r(_);var t=a(44),s=Object(t.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h2",{attrs:{id:"什么是操作系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是操作系统"}},[v._v("#")]),v._v(" 什么是操作系统")]),v._v(" "),a("p",[v._v("操作系统是管理计算机硬件和软件资源的计算机程序，是管理硬件、提供用户交互的软件系统。")]),v._v(" "),a("h3",{attrs:{id:"操作系统作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#操作系统作用"}},[v._v("#")]),v._v(" 操作系统作用")]),v._v(" "),a("ol",[a("li",[v._v("管理配置内存、决定资源供需顺序、控制输入输出设备等")]),v._v(" "),a("li",[v._v("提供了让用户和系统交互的操作界面")])]),v._v(" "),a("h3",{attrs:{id:"多道程序设计"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多道程序设计"}},[v._v("#")]),v._v(" 多道程序设计")]),v._v(" "),a("ol",[a("li",[v._v("多道程序设计是指在计算机内存中同时存放多个程序")]),v._v(" "),a("li",[v._v("多道程序在计算机的管理程序之下相互穿插运行")])]),v._v(" "),a("h3",{attrs:{id:"对多道程序的管理时操作系统的重要功能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对多道程序的管理时操作系统的重要功能"}},[v._v("#")]),v._v(" 对多道程序的管理时操作系统的重要功能")]),v._v(" "),a("ol",[a("li",[v._v("进程管理")]),v._v(" "),a("li",[v._v("文件管理")]),v._v(" "),a("li",[v._v("存储管理")]),v._v(" "),a("li",[v._v("作业管理")]),v._v(" "),a("li",[v._v("设备管理")])]),v._v(" "),a("h2",{attrs:{id:"操作系统的四个特征"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#操作系统的四个特征"}},[v._v("#")]),v._v(" 操作系统的四个特征")]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[v._v("并发\n共享\n虚拟\n异步\n")])])]),a("h3",{attrs:{id:"并发是什么-并行是什么-并发和并行有啥区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#并发是什么-并行是什么-并发和并行有啥区别"}},[v._v("#")]),v._v(" 并发是什么？并行是什么？并发和并行有啥区别？")]),v._v(" "),a("p",[v._v("并发是指两个或多个事件可以在同一时间间隔发生。并发只是把时间分成若干段，使多个任务交替的执行。比如你一边用鼠标移动打游戏，然后离开鼠标，去砸键盘, 这叫并发。")]),v._v(" "),a("p",[v._v('并行是指两个或多个事件可以在同一时刻发生。并行的关键是你有同时处理多个任务的能力。比如你一边用鼠标移动打游戏，同时语音嘴里说"队友挂机，真坑！", 这叫并行。')]),v._v(" "),a("h3",{attrs:{id:"共享是什么-共享和并发有什么关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#共享是什么-共享和并发有什么关系"}},[v._v("#")]),v._v(" 共享是什么？共享和并发有什么关系？")]),v._v(" "),a("p",[v._v("共享性表现为操作系统中的资源可供多个并发的程序共同使用")]),v._v(" "),a("p",[v._v("共享分为同时共享和互斥共享。")]),v._v(" "),a("ul",[a("li",[v._v("同时共享：系统中某些资源允许一个时间段内由多个进程(并发)同时对他进行访问。")]),v._v(" "),a("li",[v._v("互斥共享：系统中某些资源允许一个时间段内只能有一个进程对他进行访问。")])]),v._v(" "),a("p",[v._v("我们把一段时间内只允许一个进程访问的资源称为独占资源，或临界资源。")]),v._v(" "),a("h3",{attrs:{id:"虚拟"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟"}},[v._v("#")]),v._v(" 虚拟")]),v._v(" "),a("p",[v._v("虚拟性表现为把一个物理实体转变为若干个逻辑实体。物理实体是真实存在的，逻辑实体是虚拟的。")]),v._v(" "),a("p",[v._v("虚拟的技术主要有时分复用技术和空分复用技术")]),v._v(" "),a("ul",[a("li",[v._v("时分复用技术 如虚拟处理器")]),v._v(" "),a("li",[v._v("空分复用技术 如虚拟磁盘、虚拟内存")])]),v._v(" "),a("h3",{attrs:{id:"异步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步"}},[v._v("#")]),v._v(" 异步")]),v._v(" "),a("p",[v._v("CPU 正在执行一个进程，进程需要读取文件，读取文件可能要 1 个小时，那 CPU 不可能一直等一个小时，CPU 会继续把时间片分给别的进程，等文件读取完成了（类似 ajax 返回结果了），CPU 再继续执行之前被中断的进程。")]),v._v(" "),a("p",[v._v("所以异步性就是描述进程这种以不可预知的速度走走停停、何时开始何时暂停何时结束不可预知的性质。")]),v._v(" "),a("h2",{attrs:{id:"线程和进程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程和进程"}},[v._v("#")]),v._v(" 线程和进程")]),v._v(" "),a("ul",[a("li",[v._v("线程是 CPU 调度的最小单位（是建立在进程基础上的一次程序运行单位）。")]),v._v(" "),a("li",[v._v("进程是 CPU 资源分配的最小单位（是能拥有资源和独立运行的最小单位）。")]),v._v(" "),a("li",[v._v("对于操作系统来说,一个任务就是一个进程。")]),v._v(" "),a("li",[v._v("在一个进程内部,要同时做多件事,就需要同时运行多个“子任务”,我们把进程内的这些“子任务”称为线程。一个进程包含多个线程。线程之间通过读写进程中同一数据来进行通信。")])]),v._v(" "),a("h3",{attrs:{id:"进程实体"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程实体"}},[v._v("#")]),v._v(" 进程实体")]),v._v(" "),a("p",[v._v("进程实体在内存中占一个连续的内存空间，称为进程控制块。")]),v._v(" "),a("p",[v._v("进程实体包括标识符、状态、优先级、程序计数器、内存指针、上下文数据、IO 状态信息、记账信息等")]),v._v(" "),a("ol",[a("li",[v._v("标识符 唯一标记一个进程，用于区别其他进程")]),v._v(" "),a("li",[v._v("状态 标记进程的进程状态，如 运行态 阻塞态")]),v._v(" "),a("li",[v._v("程序计数器 进程即将被执行的下一条指令的地址")]),v._v(" "),a("li",[v._v("内存指针 程序代码 进程数据相关指针")]),v._v(" "),a("li",[v._v("上下文数据 进程执行时处理器存储的数据")]),v._v(" "),a("li",[v._v("被进程 IO 操作所占用的文件列表")]),v._v(" "),a("li",[v._v("记账信息 进程使用处理器的时间，时钟数总和等")])]),v._v(" "),a("h3",{attrs:{id:"线程、进程-的状态有哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程、进程-的状态有哪些"}},[v._v("#")]),v._v(" （线程、进程）的状态有哪些？")]),v._v(" "),a("ol",[a("li",[a("p",[v._v("新建状态: 使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。")])]),v._v(" "),a("li",[a("p",[v._v("就绪状态: 当线程对象调用了 start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，只要获得 CPU 的使用权就可以立即运行。")])]),v._v(" "),a("li",[a("p",[v._v("运行状态: 如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。")])]),v._v(" "),a("li",[a("p",[v._v("阻塞状态: 如果一个线程执行了 sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：")])])]),v._v(" "),a("ul",[a("li",[v._v("等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。")]),v._v(" "),a("li",[v._v("同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。")]),v._v(" "),a("li",[v._v("其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当 sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。")])]),v._v(" "),a("ol",{attrs:{start:"5"}},[a("li",[v._v("死亡状态: 一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。")])]),v._v(" "),a("h3",{attrs:{id:"进程同步-通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程同步-通信"}},[v._v("#")]),v._v(" 进程同步（通信）")]),v._v(" "),a("h4",{attrs:{id:"为什么需要进程同步-通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要进程同步-通信"}},[v._v("#")]),v._v(" 为什么需要进程同步（通信）")]),v._v(" "),a("ol",[a("li",[v._v("对竞争资源在多进程间进行使用次序的协调")]),v._v(" "),a("li",[v._v("使得并发执行的多个进程之间可以有效使用资源和相互合作")])]),v._v(" "),a("h4",{attrs:{id:"进程间同步-通信-的方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程间同步-通信-的方式"}},[v._v("#")]),v._v(" 进程间同步（通信）的方式？")]),v._v(" "),a("ol",[a("li",[v._v("管道通信")]),v._v(" "),a("li",[v._v("消息队列通信")]),v._v(" "),a("li",[v._v("信号量通信")]),v._v(" "),a("li",[v._v("信号通信")]),v._v(" "),a("li",[v._v("共享内存通信")]),v._v(" "),a("li",[v._v("套接字通信")])]),v._v(" "),a("h3",{attrs:{id:"进程的调度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程的调度"}},[v._v("#")]),v._v(" 进程的调度")]),v._v(" "),a("p",[v._v("进程调度是指计算机通过决策决定哪个就绪进程可以获得 CPU 使用权")]),v._v(" "),a("h4",{attrs:{id:"进程调度机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程调度机制"}},[v._v("#")]),v._v(" 进程调度机制")]),v._v(" "),a("ol",[a("li",[v._v("就绪队列的排队机制。将就绪进程按照一定的方式排成队列，以便调度程序可以最快找到就绪进程。")]),v._v(" "),a("li",[v._v("选择运行进程的委派机制。调度程序以一定的策略选择就绪进程，将 CPU 的资源分配给他。")]),v._v(" "),a("li",[v._v("新老进程的上下文切换机制。保存当前进程的上下文信息，装入被委派执行进程的运行上下文。")])]),v._v(" "),a("h4",{attrs:{id:"进程调度分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程调度分类"}},[v._v("#")]),v._v(" 进程调度分类")]),v._v(" "),a("p",[v._v("非抢占式调度")]),v._v(" "),a("ol",[a("li",[v._v("处理器一旦分配给某个进程，就让该进程一直使用下去")]),v._v(" "),a("li",[v._v("调度程序不以任何原因抢占正在被使用的处理器")]),v._v(" "),a("li",[v._v("直到进程完成工作或因为 IO 阻塞才会让出处理器")])]),v._v(" "),a("p",[v._v("抢占式调度")]),v._v(" "),a("ol",[a("li",[v._v("允许调度程序以一定的策略暂停当前运行的进程")]),v._v(" "),a("li",[v._v("保存好旧进程的上下文信息，分配处理器给新进程")])]),v._v(" "),a("h4",{attrs:{id:"进程调度算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程调度算法"}},[v._v("#")]),v._v(" 进程调度算法")]),v._v(" "),a("ol",[a("li",[v._v("先来先服务调度算法。按就绪队列顺序运行进程。")]),v._v(" "),a("li",[v._v("短进程优先调度算法。估计运行时间短的进程先运行。")]),v._v(" "),a("li",[v._v("高优先权优先调度算法。进程附带优先级，按优先级运行进程。")]),v._v(" "),a("li",[v._v("时间片轮转调度算法。轮转执行进程，相对公平。")])]),v._v(" "),a("h2",{attrs:{id:"死锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#死锁"}},[v._v("#")]),v._v(" 死锁")]),v._v(" "),a("p",[v._v("死锁是指两个或两个以上的进程在执行过程中，由于金正资源或者由于彼此通信而造成的一种阻塞现象，若无外力作用，它们都无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。")]),v._v(" "),a("h3",{attrs:{id:"死锁的四个必要条件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#死锁的四个必要条件"}},[v._v("#")]),v._v(" 死锁的四个必要条件")]),v._v(" "),a("ol",[a("li",[v._v("互斥条件\n"),a("ul",[a("li",[v._v("进程对资源的使用是排他性的使用。")]),v._v(" "),a("li",[v._v("某资源只能由一个进程使用，其他进程需要使用只能等待。")])])]),v._v(" "),a("li",[v._v("请求保持条件\n"),a("ul",[a("li",[v._v("进程至少保持一个资源，又提出新的资源请求。")]),v._v(" "),a("li",[v._v("新资源被占用，请求被阻塞。")]),v._v(" "),a("li",[v._v("被阻塞的进程不释放自己保持的资源。")])])]),v._v(" "),a("li",[v._v("不可剥夺条件\n"),a("ul",[a("li",[v._v("进程获得的资源在未完成使用前不能被剥夺。")]),v._v(" "),a("li",[v._v("获得的资源只能由进程自身释放。")])])]),v._v(" "),a("li",[v._v("环路等待条件\n"),a("ul",[a("li",[v._v("发生死锁时，必然存在进程-资源环形链。")])])])]),v._v(" "),a("h2",{attrs:{id:"存储管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#存储管理"}},[v._v("#")]),v._v(" 存储管理")]),v._v(" "),a("h3",{attrs:{id:"内存分配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存分配"}},[v._v("#")]),v._v(" 内存分配")]),v._v(" "),a("ol",[a("li",[v._v("单一连续分配")])]),v._v(" "),a("p",[v._v("是最简单的内存分配方式，只能在单用户、单进程的操作系统中使用。")]),v._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[v._v("固定分区分配")])]),v._v(" "),a("p",[v._v("内存被划分为若干固定大小的区域，每个分区只提供给一个程序使用，互不干扰。")]),v._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[v._v("动态分区分配")])]),v._v(" "),a("p",[v._v("根据实际的需要动态分配内存空间。有首次适应算法、最佳适应算法、快速适应算法。")]),v._v(" "),a("h3",{attrs:{id:"虚拟内存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟内存"}},[v._v("#")]),v._v(" 虚拟内存")]),v._v(" "),a("h4",{attrs:{id:"为什么需要虚拟内存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要虚拟内存"}},[v._v("#")]),v._v(" 为什么需要虚拟内存")]),v._v(" "),a("ol",[a("li",[v._v("有些进程实际需要的内存很大，超过物理内存的容量")]),v._v(" "),a("li",[v._v("多道程序设计，使得每个进程可用物理内存更加稀缺")]),v._v(" "),a("li",[v._v("不可能无线增加物理内存，物理内存总有不够的时候")])]),v._v(" "),a("h4",{attrs:{id:"虚拟内存作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟内存作用"}},[v._v("#")]),v._v(" 虚拟内存作用")]),v._v(" "),a("ol",[a("li",[v._v("虚拟内存是操作系统内存管理的关键技术")]),v._v(" "),a("li",[v._v("使得多道程序运行和大程序运行成为现实")])]),v._v(" "),a("h4",{attrs:{id:"虚拟内存怎么工作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟内存怎么工作"}},[v._v("#")]),v._v(" 虚拟内存怎么工作")]),v._v(" "),a("p",[v._v("把程序使用内存划分，把部分暂时不使用的内存放在磁盘。")]),v._v(" "),a("ol",[a("li",[v._v("程序运行时，无需全部装入内存，装载部分即可")]),v._v(" "),a("li",[v._v("如果访问页不在内存，则发生缺页中断，发生页面置换")]),v._v(" "),a("li",[v._v("从用户层面看，程序拥有很大的空间，即使虚拟内存")])]),v._v(" "),a("p",[v._v("虚拟内存实际是对物理内存的补充，速度接近于内存，成本接近于辅存")]),v._v(" "),a("p",[v._v("CPU <=> 高速缓存 <=> 主存(内存) <=> 辅存(磁盘)")]),v._v(" "),a("ol",[a("li",[v._v("高速缓存 <=> 主存(内存)主要是解决速度问题")]),v._v(" "),a("li",[v._v("主存(内存) <=> 辅存(磁盘)主要是解决容量问题")])])])}),[],!1,null,null,null);_.default=s.exports}}]);