(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{402:function(e,t,r){"use strict";r.r(t);var v=r(44),a=Object(v.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"代码检查"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#代码检查"}},[e._v("#")]),e._v(" 代码检查")]),e._v(" "),r("p",[e._v("vue2 采用 flow 进行静态类型检查工具，而 vue3 使用 typescript 作为代码检查工具。")]),e._v(" "),r("h2",{attrs:{id:"构建"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#构建"}},[e._v("#")]),e._v(" 构建")]),e._v(" "),r("p",[e._v("vue2 使用 rollup 构建，而 vue3 使用 webpack 进行构建。")]),e._v(" "),r("h2",{attrs:{id:"响应式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#响应式"}},[e._v("#")]),e._v(" 响应式")]),e._v(" "),r("p",[e._v("vue2 使用 Object.defineProperty 方法，vue3 使用 proxy 方法。")]),e._v(" "),r("h3",{attrs:{id:"vue2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue2"}},[e._v("#")]),e._v(" vue2")]),e._v(" "),r("ol",[r("li",[e._v("Object.defineProperty()这个 api 无法原生的对数组进行响应式监听")]),e._v(" "),r("li",[e._v("实现过程中对于深度嵌套的数据，递归消耗大量性能")]),e._v(" "),r("li",[e._v("我们注意到，Object.defineProperty()这种实现，以及数组的实现，都存在一个问题，那就是没办法监听到后续的手动新增删除属性元素，比如数组，直接通过索引去设置和改变值是不会触发视图更新的，当然 vue 为我们提供了 vue.set 和 vue.delete 这样的 api，但终究是不方便的")])]),e._v(" "),r("h3",{attrs:{id:"vue3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue3"}},[e._v("#")]),e._v(" vue3")]),e._v(" "),r("ol",[r("li",[e._v("Proxy 支持监听原生数组")]),e._v(" "),r("li",[e._v("Proxy 的获取数据，只会递归到需要获取的层级，不会继续递归")]),e._v(" "),r("li",[e._v("Proxy 可以监听数据的手动新增和删除")])])])}),[],!1,null,null,null);t.default=a.exports}}]);