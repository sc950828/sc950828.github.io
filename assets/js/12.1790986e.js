(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{368:function(t,i,e){"use strict";e.r(i);var a=e(44),r=Object(a.a)({},(function(){var t=this,i=t.$createElement,e=t._self._c||i;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"git-pull-和-git-fetch-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-pull-和-git-fetch-的区别"}},[t._v("#")]),t._v(" git pull 和 git fetch 的区别")]),t._v(" "),e("p",[t._v("git fetch 只是将远程仓库的变化下载下来，并没有和本地分支合并。")]),t._v(" "),e("p",[t._v("git pull 会将远程仓库的变化下载下来，并和当前分支合并。")]),t._v(" "),e("h2",{attrs:{id:"git-rebase-和-git-merge-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-rebase-和-git-merge-的区别"}},[t._v("#")]),t._v(" git rebase 和 git merge 的区别")]),t._v(" "),e("p",[t._v("git rebase 和 git merge 都是用于分支合并，关键在 commit 记录的处理上不同。")]),t._v(" "),e("p",[t._v("git merge 会新建一个新的 commit 对象，然后两个分支以前的 commit 记录都指向这个新 commit 记录。这种方法会保留之前每个分支的 commit 历史。")]),t._v(" "),e("p",[t._v("git rebase 会先找到两个分支的第一个共同的 commit 祖先记录，然后将提取当前分支这之后的所有 commit 记录，然后将这个 commit 记录添加到目标分支的最新提交后面。经过这个合并后，两个分支合并后的 commit 记录就变为了线性的记录了。")]),t._v(" "),e("h2",{attrs:{id:"git-大小写问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-大小写问题"}},[t._v("#")]),t._v(" git 大小写问题")]),t._v(" "),e("p",[t._v("默认情况下 git 是忽略区分大小写的，多人合作的情况下不规范很容易造成问题，所以开启区分大小写。可以使用 git config --list 查看 git 配置")]),t._v(" "),e("p",[t._v("开启不忽略大小写")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git config core.ignorecase false\n")])])]),e("h2",{attrs:{id:"git-中修改-gitignore-文件不起作用的解决"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-中修改-gitignore-文件不起作用的解决"}},[t._v("#")]),t._v(" git 中修改.gitignore 文件不起作用的解决")]),t._v(" "),e("p",[t._v("如果以前在 git 的管理中现在不想管理了想忽略我们可以修改.gitignore 文件，把规则添加进去，但是我们发现简单添加规则是不起作用的。因为这个文件已经被管理了所以简单的配置已经不行了。")]),t._v(" "),e("p",[t._v("我们需要使用 git rm -r --cached . 来删除 git 的缓存。.表示所有文件 我们也可以使用具体的路径。删除缓存后我们可以再使用 add .添加再提交就可以了。")])])}),[],!1,null,null,null);i.default=r.exports}}]);