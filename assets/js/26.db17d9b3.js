(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{383:function(e,s,a){"use strict";a.r(s);var t=a(44),v=Object(t.a)({},(function(){var e=this,s=e.$createElement,a=e._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"什么是语义化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是语义化"}},[e._v("#")]),e._v(" 什么是语义化？")]),e._v(" "),a("p",[e._v("HTML5 的语义化指的是合理使用语义化的标签来创建页面结构，如 header,footer,nav，从标签上即可以直观的知道这个标签的作用，而不是滥用 div。")]),e._v(" "),a("h2",{attrs:{id:"语义化的优点有"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#语义化的优点有"}},[e._v("#")]),e._v(" 语义化的优点有")]),e._v(" "),a("ol",[a("li",[e._v("代码结构清晰，易于阅读，利于开发和维护")]),e._v(" "),a("li",[e._v("提高用户体验，在样式加载失败时，页面结构清晰")]),e._v(" "),a("li",[e._v("方便其他设备解析（如屏幕阅读器）根据语义渲染网页。")]),e._v(" "),a("li",[e._v("有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重")])]),e._v(" "),a("h2",{attrs:{id:"渲染模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#渲染模式"}},[e._v("#")]),e._v(" 渲染模式")]),e._v(" "),a("h3",{attrs:{id:"怪异模式-兼容模式、混杂模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#怪异模式-兼容模式、混杂模式"}},[e._v("#")]),e._v(" 怪异模式（兼容模式、混杂模式）")]),e._v(" "),a("p",[e._v("服务于旧式规则，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。")]),e._v(" "),a("h3",{attrs:{id:"标准模式-严格模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#标准模式-严格模式"}},[e._v("#")]),e._v(" 标准模式（严格模式）")]),e._v(" "),a("p",[e._v("服务于标准规则，标准模式的排版 和 JS 运作模式都是以该浏览器支持的最高标准运行")]),e._v(" "),a("h3",{attrs:{id:"近似标准模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#近似标准模式"}},[e._v("#")]),e._v(" 近似标准模式")]),e._v(" "),a("p",[e._v("基本是标准模型，有一些是自己的调整")]),e._v(" "),a("h3",{attrs:{id:"标准模式和混杂模式的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#标准模式和混杂模式的区别"}},[e._v("#")]),e._v(" 标准模式和混杂模式的区别？")]),e._v(" "),a("p",[e._v("盒模型的处理差异：标准 CSS 盒模型的宽度和高度等于内容区的高度和宽度，不包含内边距和边框，而 IE6 之前的浏览器实现的盒模型的宽高计算方式是包含内边距和边框的。因此，对于 IE，怪异模式和标准模式下的盒模型宽高计算方式是不一样的；")]),e._v(" "),a("p",[e._v("行内元素的垂直对齐：很多早期的浏览器对齐图片至包含它们的盒子的下边框，虽然 CSS 的规范要求它们被对齐至盒内文本的基线。标准模式下，基于 Gecko 的浏览器将会对齐至基线，而在 quirks 模式下它们会对齐至底部。最直接的例子就是图片的显示。在标准模式下，图片并不是与父元素的下边框对齐的，如果仔细观察，你会发现图片与父元素下边框之间存在一点小空隙。那是因为标准模式下，图片是基线对齐的。而怪异模式下，则不存在这个问题")]),e._v(" "),a("h2",{attrs:{id:"meta"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#meta"}},[e._v("#")]),e._v(" meta")]),e._v(" "),a("h3",{attrs:{id:"http-equiv-【重要关键词】"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-equiv-【重要关键词】"}},[e._v("#")]),e._v(" http-equiv 【重要关键词】")]),e._v(" "),a("ul",[a("li",[e._v("content-type 定义字符编码不推荐使用，改用 charset 属性")]),e._v(" "),a("li",[e._v("refresh：指定以秒为单位，执行重载和重定向")])]),e._v(" "),a("h3",{attrs:{id:"name-【-重要关键词】"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#name-【-重要关键词】"}},[e._v("#")]),e._v(" name 【 重要关键词】")]),e._v(" "),a("ul",[a("li",[e._v("application-name 应用程序名称")]),e._v(" "),a("li",[e._v("keywords 用来告诉搜索引擎你网页的关键字是什么")]),e._v(" "),a("li",[e._v("description 用来告诉搜索引擎你的网站主要内容")]),e._v(" "),a("li",[e._v("author 当前页的作者名")]),e._v(" "),a("li",[e._v("viewport 设置浏览器视口")])]),e._v(" "),a("h3",{attrs:{id:"content-具体描述-、不能单独存在-与-name-或-http-equiv-配合使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#content-具体描述-、不能单独存在-与-name-或-http-equiv-配合使用"}},[e._v("#")]),e._v(" content 具体描述 、不能单独存在 与 name 或 http-equiv 配合使用")]),e._v(" "),a("h3",{attrs:{id:"charset-html5-推荐使用-utf-8-简化了不同脚本对文件中字符的处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#charset-html5-推荐使用-utf-8-简化了不同脚本对文件中字符的处理"}},[e._v("#")]),e._v(" charset（HTML5）：推荐使用 utf-8 简化了不同脚本对文件中字符的处理")]),e._v(" "),a("h2",{attrs:{id:"src-与-href"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#src-与-href"}},[e._v("#")]),e._v(" src 与 href")]),e._v(" "),a("p",[e._v("src：引入 将指定资源应用到文档内")]),e._v(" "),a("p",[e._v("href：引用 建立与当前文档之间的链接")]),e._v(" "),a("h2",{attrs:{id:"a-标签属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#a-标签属性"}},[e._v("#")]),e._v(" a 标签属性")]),e._v(" "),a("ol",[a("li",[a("code",[e._v("_self")]),e._v("（默认值）：在当前窗口打开")]),e._v(" "),a("li",[a("code",[e._v("_blank")]),e._v(" 在新窗口中打开")]),e._v(" "),a("li",[a("code",[e._v("_parent")]),e._v(" 在父级窗口打开")]),e._v(" "),a("li",[a("code",[e._v("_top")]),e._v(" 在顶级窗口打开")])]),e._v(" "),a("h2",{attrs:{id:"localstorage-和-sessionstorage-的特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#localstorage-和-sessionstorage-的特点"}},[e._v("#")]),e._v(" localStorage 和 sessionStorage 的特点")]),e._v(" "),a("ol",[a("li",[e._v("localStorage 只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份 localStorage 数据。")]),e._v(" "),a("li",[e._v("sessionStorage 比 localStorage 更严苛一点，除了协议、主机名、端口外，还要求在同一窗口。")]),e._v(" "),a("li",[e._v("localStorage 会永久存在除非手动清除。")]),e._v(" "),a("li",[e._v("sessionStorage 在关闭页面或浏览器的时候就会清除。")]),e._v(" "),a("li",[e._v("localStorage 和 sessionStorage key 必须是字符串类型。"),a("strong",[e._v("存储的数据值都是字符串类型的数据，取出来的数据也是字符串类型，因此如果存储的对象不是字符串，则要转换成字符串数据类型。")])]),e._v(" "),a("li",[e._v("localStorage 和 sessionStorage 存储大小可以达到 5M 或更大。")])]),e._v(" "),a("h2",{attrs:{id:"cookie"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cookie"}},[e._v("#")]),e._v(" cookie")]),e._v(" "),a("p",[e._v("HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。")]),e._v(" "),a("ol",[a("li",[e._v("cookie 数据始终在同源（协议、主机、端口相同）的 http 请求中携带（即使不需要），会在浏览器和服务器间来回传递。")]),e._v(" "),a("li",[e._v("cookie 数据大小不能超过 4 k。")]),e._v(" "),a("li",[e._v("cookie 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。")]),e._v(" "),a("li",[e._v("cookie 在所有同源窗口中都是共享的。")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 请求头\nCookie: a=xxx;b=xxx\n// 响应头\nSet-Cookie: a=xxx\nset-Cookie: b=xxx\n")])])]),a("h3",{attrs:{id:"生存周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生存周期"}},[e._v("#")]),e._v(" 生存周期")]),e._v(" "),a("p",[e._v("Cookie 的有效期可以通过 Expires 和 Max-Age 两个属性来设置。")]),e._v(" "),a("ul",[a("li",[e._v("Expires 即过期时间")]),e._v(" "),a("li",[e._v("Max-Age 用的是一段时间间隔，单位是秒，从浏览器收到报文开始计算。")])]),e._v(" "),a("p",[e._v("若 Cookie 过期，则这个 Cookie 会被删除，并不会发送给服务端。")]),e._v(" "),a("h3",{attrs:{id:"作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#作用域"}},[e._v("#")]),e._v(" 作用域")]),e._v(" "),a("p",[e._v("关于作用域也有两个属性: Domain 和 path, 给 Cookie 绑定了域名和路径，在发送请求之前，发现域名或者路径和这两个属性不匹配，那么就不会带上 Cookie。值得注意的是，对于路径来说，/表示域名下的任意路径都允许使用 Cookie。")]),e._v(" "),a("h3",{attrs:{id:"安全相关"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#安全相关"}},[e._v("#")]),e._v(" 安全相关")]),e._v(" "),a("p",[e._v("如果带上 Secure，说明只能通过 HTTPS 传输 cookie。")]),e._v(" "),a("p",[e._v("如果 cookie 字段带上 HttpOnly，那么说明只能通过 HTTP 协议传输，不能通过 JS 访问，这也是预防 XSS 攻击的重要手段。")]),e._v(" "),a("p",[e._v("相应的，对于 CSRF 攻击的预防，也有 SameSite 属性。SameSite 可以设置为三个值，Strict、Lax 和 None。")]),e._v(" "),a("ul",[a("li",[e._v("a. 在 Strict 模式下，浏览器完全禁止第三方请求携带 Cookie。比如请求 randy.com 网站只能在 randy.com 域名当中请求才能携带 Cookie，在其他网站请求都不能。")]),e._v(" "),a("li",[e._v("b. 在 Lax 模式，就宽松一点了，但是只能在 get 方法提交表单况或者 a 标签发送 get 请求的情况下可以携带 Cookie，其他情况均不能。")]),e._v(" "),a("li",[e._v("c. 在 None 模式下，也就是默认模式，请求会自动携带上 Cookie。")])]),e._v(" "),a("h3",{attrs:{id:"cookie-的缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cookie-的缺点"}},[e._v("#")]),e._v(" Cookie 的缺点")]),e._v(" "),a("p",[e._v("容量缺陷。Cookie 的体积上限只有 4KB，只能用来存储少量的信息。")]),e._v(" "),a("p",[e._v("性能缺陷。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。但可以通过 Domain 和 Path 指定作用域来解决。")]),e._v(" "),a("p",[e._v("安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在 HttpOnly 为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。")]),e._v(" "),a("h2",{attrs:{id:"session"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#session"}},[e._v("#")]),e._v(" session")]),e._v(" "),a("p",[e._v("Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。")]),e._v(" "),a("h2",{attrs:{id:"cookie-和-session-流程介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cookie-和-session-流程介绍"}},[e._v("#")]),e._v(" cookie 和 session 流程介绍")]),e._v(" "),a("p",[e._v("1、用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。")]),e._v(" "),a("p",[e._v("2、当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。")]),e._v(" "),a("p",[e._v("3、根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。")]),e._v(" "),a("h2",{attrs:{id:"既然服务端是根据-cookie-中的信息判断用户是否登录-那么如果浏览器中禁止了-cookie-如何保障整个机制的正常运转"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#既然服务端是根据-cookie-中的信息判断用户是否登录-那么如果浏览器中禁止了-cookie-如何保障整个机制的正常运转"}},[e._v("#")]),e._v(" 既然服务端是根据 Cookie 中的信息判断用户是否登录，那么如果浏览器中禁止了 Cookie，如何保障整个机制的正常运转")]),e._v(" "),a("p",[e._v("第一种方案，每次请求中都携带一个 SessionID 的参数，也可以 Post 的方式提交，也可以在请求的地址后面拼接 xxx?SessionID=123456...。")]),e._v(" "),a("p",[e._v("第二种方案，Token 机制。Token 机制多用于 App 客户端和服务器交互的模式，也可以用于 Web 端做用户状态管理。\nToken 的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。Token 机制和 Cookie 和 Session 的使用机制比较类似。\n当用户第一次登录后，服务器根据提交的用户信息生成一个 Token，响应时将 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次登录验证。")]),e._v(" "),a("h2",{attrs:{id:"如何考虑分布式-session-问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何考虑分布式-session-问题"}},[e._v("#")]),e._v(" 如何考虑分布式 Session 问题？")]),e._v(" "),a("p",[e._v("在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。\n分布式 Session 一般会有以下几种解决方案")]),e._v(" "),a("ol",[a("li",[e._v("Nginx ip_hash 策略，服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。")]),e._v(" "),a("li",[e._v("Session 复制，任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。")]),e._v(" "),a("li",[e._v("共享 Session，服务端无状态话，将用户的 Session 等信息使用缓存中间件来统一管理，保障分发到每一个服务器的响应结果都一致。")])]),e._v(" "),a("h2",{attrs:{id:"json-web-token"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#json-web-token"}},[e._v("#")]),e._v(" JSON Web Token")]),e._v(" "),a("p",[e._v("JSON Web Token ，简称 JWT，它和 Session 都可以为网站提供用户的身份认证")]),e._v(" "),a("p",[e._v("JWT 中存储的信息是经过数字签名的，因此可以被信任和理解。一般我们使用用户 id、name 等一些信息通过秘钥加密生成一个 token，返回给客户端。")]),e._v(" "),a("p",[e._v("使用方式")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Authorization: Bearer <jwt token>\n")])])]),a("p",[e._v("优点：")]),e._v(" "),a("ol",[a("li",[e._v("Session Cookies 只能用在单个节点的域或者它的子域中有效。如果它们尝试通过第三个节点访问，就会被禁止。如果你希望自己的网站和其他站点建立安全连接时，这是一个问题。\n使用 JWT 可以解决这个问题，使用 JWT 能够通过多个节点进行用户认证，也就是我们常说的跨域认证。")]),e._v(" "),a("li",[e._v("jwt 直接解密即可得到用户信息不需要额外的数据库查询操作，性能大大提高。")])]),e._v(" "),a("h2",{attrs:{id:"如何模拟双向通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何模拟双向通信"}},[e._v("#")]),e._v(" 如何模拟双向通信")]),e._v(" "),a("p",[e._v("html5 新出了 websocket 全双工通讯协议，使双向通讯成为可能。下面介绍三种模拟双向通讯的方法。")]),e._v(" "),a("h3",{attrs:{id:"短轮询"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#短轮询"}},[e._v("#")]),e._v(" 短轮询")]),e._v(" "),a("p",[e._v("客户端定时向服务器发送 Ajax 请求，服务器接到请求后马上返回响应信息并关闭连接。")]),e._v(" "),a("p",[e._v("优点")]),e._v(" "),a("ul",[a("li",[e._v("后端编写容易")])]),e._v(" "),a("p",[e._v("缺点")]),e._v(" "),a("ul",[a("li",[e._v("请求中大半是无用，浪费宽带和服务器资源")])]),e._v(" "),a("p",[e._v("适用 ： 小型应用")]),e._v(" "),a("h3",{attrs:{id:"长轮询"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#长轮询"}},[e._v("#")]),e._v(" 长轮询")]),e._v(" "),a("p",[e._v("客户端向服务器发送 Ajax 请求，服务器接到请求后 hold 住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。")]),e._v(" "),a("p",[e._v("优点")]),e._v(" "),a("ul",[a("li",[e._v("在无消息的情况下不会频繁的请求，耗费资源小")])]),e._v(" "),a("p",[e._v("缺点")]),e._v(" "),a("ul",[a("li",[e._v("服务器 hold 连接会消耗资源")]),e._v(" "),a("li",[e._v("返回数据顺序无保证，难于管理维护")])]),e._v(" "),a("h3",{attrs:{id:"长连接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#长连接"}},[e._v("#")]),e._v(" 长连接")]),e._v(" "),a("p",[e._v("在页面嵌入一个隐藏 iframe，将这个隐藏 iframe 的 src 属性设为对一个长连接的请求，服务器端就能源源不断的往客户端输入数据")]),e._v(" "),a("p",[e._v("优点")]),e._v(" "),a("ul",[a("li",[e._v("消息及时到达，不发无用请求")]),e._v(" "),a("li",[e._v("管理起来也相对方便")])]),e._v(" "),a("p",[e._v("缺点")]),e._v(" "),a("ul",[a("li",[e._v("服务器维护一个长连接会增加开销")])]),e._v(" "),a("h3",{attrs:{id:"sse"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sse"}},[e._v("#")]),e._v(" SSE")]),e._v(" "),a("p",[e._v("所谓 SSE（Sever-Sent Event），就是浏览器向服务器发送一个 HTTP 请求，保持长连接，服务器不断单向地向浏览器推送“信息”（message），这么做是为了节约网络资源，不用一直发请求，建立新连接。其实就是类似长连接，他有一个浏览器内置 EventSource 对象来操作")]),e._v(" "),a("p",[e._v("优点")]),e._v(" "),a("p",[e._v("优点就是当然是他是一个 http 的请求啊，由于被浏览器封装了，所以使用简单，节约开发成本")]),e._v(" "),a("p",[e._v("缺点")]),e._v(" "),a("p",[e._v("缺点也相当明显，无法实现双向消息")])])}),[],!1,null,null,null);s.default=v.exports}}]);