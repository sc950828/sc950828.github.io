(window.webpackJsonp=window.webpackJsonp||[]).push([[96],{452:function(t,a,e){"use strict";e.r(a);var v=e(44),n=Object(v.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"http-是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-是什么"}},[t._v("#")]),t._v(" http 是什么？")]),t._v(" "),e("ul",[e("li",[t._v("http 是超文本传输协议，它使用 TCP 作为传 输层协议，保证了数据传输的可靠性。属于网络层级中的应用层。")]),t._v(" "),e("li",[t._v("http 默认端口 80，https 默认端口 443。")])]),t._v(" "),e("h2",{attrs:{id:"http-的特点是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-的特点是什么"}},[t._v("#")]),t._v(" http 的特点是什么？")]),t._v(" "),e("ol",[e("li",[t._v("无状态 就是 http 传输是没有记忆能力，第一次传送的数据如果第二次还要传的话，需要重新传。")]),t._v(" "),e("li",[t._v("无连接 传送完数据之后就断开了连接。")]),t._v(" "),e("li",[t._v("媒体独立 可以传送任何数据类型。")])]),t._v(" "),e("h2",{attrs:{id:"连接模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#连接模式"}},[t._v("#")]),t._v(" 连接模式")]),t._v(" "),e("p",[t._v("HTTP 有两种连接模式，一种是持续连接，一种非持续连接。非持续连接指的是服务器必须为每一个请求的对象建立和维护 一个全新的连接。持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP 连接三次握手时所花费的时间。在 HTTP1.0 以前使用的非持续的连接，但是可以在请求时，加上 Connection: keep-alive 来要求服务器不要关闭 TCP 连接。HTTP1.1 以后默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持同时建立 6 个持久连接。")]),t._v(" "),e("h2",{attrs:{id:"请求响应的组成"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#请求响应的组成"}},[t._v("#")]),t._v(" 请求响应的组成")]),t._v(" "),e("ul",[e("li",[t._v("请求行、请求头、空行、请求体")]),t._v(" "),e("li",[t._v("状态行、响应头、空行、响应体")])]),t._v(" "),e("p",[t._v("空行主要用来区分开头部和实体")]),t._v(" "),e("h2",{attrs:{id:"请求行-状态行包括什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#请求行-状态行包括什么"}},[t._v("#")]),t._v(" 请求行 状态行包括什么？")]),t._v(" "),e("ul",[e("li",[t._v("请求行有协议版本 请求路径 请求方法")]),t._v(" "),e("li",[t._v("状态行有协议版本 状态码 相应的状态信息(原因)")])]),t._v(" "),e("h2",{attrs:{id:"常见的请求头有什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常见的请求头有什么"}},[t._v("#")]),t._v(" 常见的请求头有什么?")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("Accept 可以接受的数据类型\nAccept-Charset 可接受的字符集\nAccept-Language 可接受的响应内容语言列表\nAccept-Encoding 告诉服务器，客户机支持的数据压缩格式。\nContent-Type 请求参数的数据类型\nAuthorization HTTP授权的授权证书 一般我们用来存放token Authorization: Bearer QWxhZGRpbjpvcGVuIHNlc2FtZQ==\nConnection 表示是否需要持久连接。（HTTP 1.1默认进行持久连接）\nHost 请求服务器的域名及端口号(服务端)\nOrigin: 请求的来源域名和端口号 （跨域请求时，浏览器会自动带上这个头信息）\nReferer: 当前发送请求的域名及端口号及参数，请求资源的完整URI(客户端)https:/localhost:8081/link?query=xxxxx\nRemote Address 服务器ip和端口\nReferrer-Policy（来源协议）用来规定什么情况下显示Referer字段及refer字段内显示多少信息。\nCookie cookie信息\nUser-Agent 浏览器的一些信息\nDate 客户机通过这个头告诉服务器，客户机当前请求时间\nCache-Control 是否使用缓存 max-age no-cache no-store等等\nIf-Modify-Since 协商缓存标志 值等于上次响应的last-Modify的值\nIf-None-Match 协商缓存标志 值等于上次响应的ETag字符串\n")])])]),e("h2",{attrs:{id:"常见的响应头有什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常见的响应头有什么"}},[t._v("#")]),t._v(" 常见的响应头有什么？")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("Expires 是否强缓存 (老版本)是个将来的时间戳，有问题后来使用cache-control\nDate 服务端发送资源时的服务器时间\nCache-Control 是否强缓存 他的max-age值表示在多少时间内有效\nContent-Type 响应的数据类型\nContent-Encoding 告诉浏览器数据压缩的格式\nContent-Language 告诉浏览器使用的语言\nAccess-Control-Allow-Origin 指定哪些域名可以访问服务器\nAccess-Control-Allow-Methods 哪些方法\nAccess-Control-Allow-Headers 哪些请求头\nLast-Modified 是否协商缓存 是个时间戳 (老版本)有问题后来使用Etag，比如编辑了文件并没有改变东西会有问题\nETag 是否使用协商缓存 由服务端为每个文件生成唯一的字符\nSet-Cookie: 服务端发送的cookie\n")])])]),e("h2",{attrs:{id:"常见的通用标头有什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常见的通用标头有什么"}},[t._v("#")]),t._v(" 常见的通用标头有什么？")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("Date\nCache-Control\nConnection\n")])])]),e("h2",{attrs:{id:"常见的实体标头有什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常见的实体标头有什么"}},[t._v("#")]),t._v(" 常见的实体标头有什么？")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("Content-Length\nContent-Language\nContent-Encoding\n")])])]),e("h2",{attrs:{id:"对-accept-系列字段了解多少"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对-accept-系列字段了解多少"}},[t._v("#")]),t._v(" 对 Accept 系列字段了解多少？")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("对于 accept 系列字段的介绍分为四个部分: 数据格式、压缩方式、支持语言和字符集。\n浏览器告知服务器自己对这四个部分想要收到特定类型的数据。\n\n客户端接收数据想要的数据格式 accept 对于应服务端的content-type\n\n- text： text/html, text/plain, text/css 等\n- image: image/gif, image/jpeg, image/png 等\n- audio/video: audio/mpeg, video/mp4 等\n- application: application/json, application/javascript, application/pdf, application/octet-stream\n\n客户端接收数据想要的数据压缩格式 accept-encoding 对应服务端的 content-encoding\n\n- gzip: 当今最流行的压缩格式\n- deflate: 另外一种著名的压缩格式\n- br: 一种专门为 HTTP 发明的压缩算法\n\n客户端接收数据想要的语言类型 accept-language 对应服务端的content-language\n\n- accept-language: zh-CN, zh, en\n\n客户端就收数据想要的字符集 accept-charset 服务端没有对应的content-charset, 而是直接放在了content-type中，以charset属性指定。\n\n- Accept-Charset: charset=utf-8\n- Content-Type: text/html; charset=utf-8\n")])])]),e("h2",{attrs:{id:"状态码表示什么含义-列出一些常见的状态码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#状态码表示什么含义-列出一些常见的状态码"}},[t._v("#")]),t._v(" 状态码表示什么含义？列出一些常见的状态码？")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("1xx 接收的请求正在处理\n2xx 请求正常处理完毕\n3xx 需要进行附加操作完成请求 比如重定向\n4xx 服务端无法处理请求 客户端错误\n5xx 服务端处理请求出错\n")])])]),e("ul",[e("li",[t._v("101 Switching Protocols。在 HTTP 升级为 WebSocket 的时候，如果服务器同意变更，就会发送状态码 101。")]),t._v(" "),e("li",[t._v("200 成功 通常在响应体中放有数据。")]),t._v(" "),e("li",[t._v("204 No Content 含义与 200 相同，但响应头后没有 body 数据。")]),t._v(" "),e("li",[t._v("206 Partial Content 顾名思义，表示部分内容，它的使用场景为 HTTP 分块下载和断电续传，当然也会带上相应的响应头字段 Content-Range。")]),t._v(" "),e("li",[t._v("301 永久重定向 比如你的网站从 HTTP 升级到了 HTTPS 了，以前的站点再也不用了，应当返回 301，这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。而如果只是暂时不可用，那么直接返回 302 即可，和 301 不同的是，浏览器并不会做缓存优化。")]),t._v(" "),e("li",[t._v("302 临时重定向 会改变请求方法 把 post 改为 get。")]),t._v(" "),e("li",[t._v("307 临时重定向 不会改变请求方式")]),t._v(" "),e("li",[t._v("304 Not Modified: 当协商缓存命中时会返回这个状态码。")]),t._v(" "),e("li",[t._v("400 请求错误 客户端错误")]),t._v(" "),e("li",[t._v("401 未授权")]),t._v(" "),e("li",[t._v("403 请求被拒绝")]),t._v(" "),e("li",[t._v("404 资源缺失找不到")]),t._v(" "),e("li",[t._v("405 Method Not Allowed: 请求方法不被服务器端允许。")]),t._v(" "),e("li",[t._v("408 Request Timeout: 服务器等待了太长时间。")]),t._v(" "),e("li",[t._v("409 Conflict: 多个请求发生了冲突。")]),t._v(" "),e("li",[t._v("413 Request Entity Too Large: 请求体的数据过大。")]),t._v(" "),e("li",[t._v("414 Request-URI Too Long: 请求行里的 URI 太大。")]),t._v(" "),e("li",[t._v("429 Too Many Request: 客户端发送的请求过多。")]),t._v(" "),e("li",[t._v("431 Request Header Fields Too Large 请求头的字段内容太大。")]),t._v(" "),e("li",[t._v("500 服务端错误")]),t._v(" "),e("li",[t._v("501 Not Implemented: 表示客户端请求的功能还不支持。")]),t._v(" "),e("li",[t._v("502 Bad Gateway: 服务器自身是正常的，但访问的时候出错了，啥错误咱也不知道。")]),t._v(" "),e("li",[t._v("503 Service Unavailable: 表示服务器当前很忙，暂时无法响应服务")])]),t._v(" "),e("h2",{attrs:{id:"代理和网关"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代理和网关"}},[t._v("#")]),t._v(" 代理和网关")]),t._v(" "),e("h3",{attrs:{id:"代理分为正向代理反向代理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代理分为正向代理反向代理"}},[t._v("#")]),t._v(" 代理分为正向代理反向代理")]),t._v(" "),e("p",[t._v("正向代理")]),t._v(" "),e("ul",[e("li",[t._v("由客户端向代理服务器发出请求，并指定目标访问服务器，然后，代理服务器向源服务器转交需求，并将获得的内容返回给客户端客户端知道真正要请求的服务器，服务端不知道真实的客户端是谁。")])]),t._v(" "),e("p",[t._v("反向代理")]),t._v(" "),e("ul",[e("li",[t._v("由客户端向代理服务器发出请求，代理服务器判断目标服务器，然后向目标服务器发送请求获取响应，然后把数据发送给客户端。对客户端来说并不知道真正的服务器是谁，把代理服务器当成服务器。反向代理器一般用来实现负载平衡。")])]),t._v(" "),e("p",[t._v("常见代理服务器的作用")]),t._v(" "),e("ul",[e("li",[t._v("缓存代理。代理转发响应时 缓存代理会将数据缓存到自己的服务器上 下次请求来的时候直接将缓存的数据返回")]),t._v(" "),e("li",[t._v("负载均衡。客户端的请求只会先到达代理服务器，后面到底有多少源服务器，IP 都是多少，客户端是不知道的。因此，这个代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各台源服务器的负载尽量平均。当然，这样的算法有很多，包括随机算法、轮询、一致性 hash、LRU(最近最少使用)等等。")]),t._v(" "),e("li",[t._v("保障安全。利用心跳机制监控后台的服务器，一旦发现故障机就将其踢出集群。并且对于上下行的数据进行过滤，对非法 IP 限流，这些都是代理服务器的工作。")]),t._v(" "),e("li",[t._v("透明代理 只负责转发请求和响应 不对数据进行操作")])]),t._v(" "),e("p",[t._v("代理相关头部字段")]),t._v(" "),e("ul",[e("li",[t._v("Via 假如有一个客户端 -> 代理 1 -> 代理 2 -> 源服务器的请求。在源服务器收到请求后，会在请求头拿到这个字段:Via: proxy_server1, proxy_server2。而源服务器响应时，最终在客户端会拿到这样的响应头:Via: proxy_server2, proxy_server1")]),t._v(" "),e("li",[t._v("X-Forwarded-For 字面意思就是为谁转发, 它记录的是请求方的 IP 地址(注意，和 Via 区分开，X-Forwarded-For 记录的是请求方这一个 IP，这意味着每经过一个不同的代理，这个字段的名字都要变，从客户端到代理 1，这个字段是客户端的 IP，从代理 1 到代理 2，这个字段就变为了代理 1 的 IP。意味着代理必须解析 HTTP 请求头，然后修改，比直接转发数据性能下降。)。")]),t._v(" "),e("li",[t._v("X-Real-IP 是一种获取用户真实 IP 的字段，不管中间经过多少代理，这个字段始终记录最初的客户端的 IP。相应的，还有 X-Forwarded-Host 和 X-Forwarded-Proto，分别记录客户端(注意哦，不包括代理)的域名和协议名。")])]),t._v(" "),e("h3",{attrs:{id:"网关"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#网关"}},[t._v("#")]),t._v(" 网关")]),t._v(" "),e("p",[t._v("网关会接收请求转发请求 接收响应转发响应 而且还能提供非 http 协议服务。")]),t._v(" "),e("h2",{attrs:{id:"cdn"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cdn"}},[t._v("#")]),t._v(" CDN")]),t._v(" "),e("p",[t._v("CDN 全称为内容分发网络 (Content Delivery Network)，它能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上，以提高用户访问网站的相应速度。")]),t._v(" "),e("p",[t._v("使用 CDN 的缺陷是需要注意缓存。修改可能不会立即生效，需要刷新缓存。")]),t._v(" "),e("p",[t._v("分发服务系统")]),t._v(" "),e("p",[t._v("分发服务系统的基元是 Cache 设备，它会同步源站点的内容并负责响应用户的访问请求，把缓存在本地的内容快速的提供给用户。")]),t._v(" "),e("p",[t._v("负载均衡系统")]),t._v(" "),e("p",[t._v("对发起请求的用户进行访问调度，确定提供给用户的最终实际访问地址。该系统分为全局负载均衡 (GSLB) 和本地负载均衡 (SLB)。GBLB 主要根据“就近原则”，通过对每个服务节点进行最优判断，向用户提供最合适的 Cache 设备。SLB 主要负责节点内部的设备负载均衡。")]),t._v(" "),e("p",[t._v("CDN 厂商做域名解析，它也是利用 DNS 的重定向技术，DNS 服务器会返回一个跟用户最接近的点的 IP 地址给用户，CDN 节点的服务器负责响应用户的请求，提供所需的内容，CDN 厂商的域名解析服务器用户量多，被访问的次数也多，域名解析服务器的 A 记录基本上会被各地运营商的 DNS 一直缓存着，所以服务效果也是最好的。")]),t._v(" "),e("h2",{attrs:{id:"dns-协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dns-协议"}},[t._v("#")]),t._v(" DNS 协议")]),t._v(" "),e("p",[t._v("DNS 协议提供的是一种域名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。DNS 协议运行在 UDP 协议之上，使用 53 号 端口。")]),t._v(" "),e("p",[t._v("www.qq.com. 来说，等等，是不是多打了一个点，当然不是多打，这个最后的 . 代表的是根域名，默认情况下所有的网址的最后一位都是 .，只不过为了方便用户，通常都会省略，浏览器在 DNS 解析 时会自动加上的，com 是顶级域名，qq 是二级域名，www 是三级域名，如果 www 前还有，那就四级等等。")]),t._v(" "),e("h3",{attrs:{id:"顶级域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#顶级域"}},[t._v("#")]),t._v(" 顶级域")]),t._v(" "),e("p",[t._v("顶级域分为国家顶级域和通用顶级域")]),t._v(" "),e("p",[t._v("国家顶级域有 cn、us、uk、ca 等")]),t._v(" "),e("p",[t._v("通用顶级域有 com、net、gov、org 等")]),t._v(" "),e("h3",{attrs:{id:"二级域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二级域"}},[t._v("#")]),t._v(" 二级域")]),t._v(" "),e("p",[t._v("常见的有 aliyun、qq、taobao、baidu、google、alibaba 等")]),t._v(" "),e("h2",{attrs:{id:"dns-解析步骤"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dns-解析步骤"}},[t._v("#")]),t._v(" DNS 解析步骤")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("系统会检查浏览器缓存中有没有这个域名对应的解析过的 IP 地址，如果缓存中有，这个解析过程就将结束。浏览器缓存是受这个域名的失效时间和缓存的空间大小控制的。")])]),t._v(" "),e("li",[e("p",[t._v("如果用户的浏览器缓存中没有，浏览器会查找操作系统缓存中即为本地的 Host 文件。")])]),t._v(" "),e("li",[e("p",[t._v("检查路由器缓存")])]),t._v(" "),e("li",[e("p",[t._v("如果前几步都没没找到，会向 ISP(网络服务提供商)的 LDNS（本地服务器）查询。比如你用的是电信的网络，则会进入电信的 DNS 缓存服务器中进行查找")])])]),t._v(" "),e("p",[t._v("如果 LDNS （本地服务器）没找到，会向根域名服务器(Root Server)请求解析，分为以下几步：")]),t._v(" "),e("ul",[e("li",[t._v("根域名服务器收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名 ( .com ) 服务器 IP 告诉本地域名服务器，然后本地域名服务器发送请求到顶级域名服务器。")]),t._v(" "),e("li",[t._v("顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名（ qq.com ）服务器的 IP 地址告诉本地域名服务器，然后本地域名服务器发送请求到二级域名服务器。")]),t._v(" "),e("li",[t._v("二级域名服务器接受到请求后查询自己的缓存，如果没有则进入三级域名服务器（ www.qq.com ）进行查找，并重复该步骤直至找到正确纪录")]),t._v(" "),e("li",[t._v("本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个 IP 地址与 Web 服务器建立链接。")])]),t._v(" "),e("h2",{attrs:{id:"dns-优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dns-优化"}},[t._v("#")]),t._v(" DNS 优化")]),t._v(" "),e("p",[t._v("我们购买域名做域名解析时，有一个 TTL 值，这个值表示 DNS 服务器解析域名时记录在 DNS 服务器上的缓存时间。可以将其设置大一点，一般设置 TTL 3600 即可。")]),t._v(" "),e("h2",{attrs:{id:"http-有哪些方法-分别有什么作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-有哪些方法-分别有什么作用"}},[t._v("#")]),t._v(" http 有哪些方法，分别有什么作用？")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("http1.0\n  get  获取数据\n  post 新增数据\n  head 获取响应头，使用场景是请求可能是大文件的时候，先发送head请求判断资源大小是否能下载。\nhttp1.1\n  put  更新 全部更新\n  patch 更新，部分更新\n  delete 删除\n  options 询问，获取目的资源所支持的通信选项。非简单请求在跨域的时候会发送该请求。\n  trace 回显服务器收到的请求，主要用于测试或诊断\n  connect HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器\n")])])]),e("h2",{attrs:{id:"get-和-post-有什么区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#get-和-post-有什么区别"}},[t._v("#")]),t._v(" GET 和 POST 有什么区别？")]),t._v(" "),e("ol",[e("li",[t._v("从缓存的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。")]),t._v(" "),e("li",[t._v("从编码的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。")]),t._v(" "),e("li",[t._v("从参数的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。")]),t._v(" "),e("li",[t._v("从幂等性的角度，GET 是幂等的，而 POST 不是。(幂等表示执行相同的操作，结果也是相同的)")]),t._v(" "),e("li",[t._v("从 TCP 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)")])]),t._v(" "),e("h2",{attrs:{id:"如何理解-uri"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何理解-uri"}},[t._v("#")]),t._v(" 如何理解 URI？")]),t._v(" "),e("p",[t._v("URI, 全称为(Uniform Resource Identifier), 也就是统一资源标识符，它的作用很简单，就是区分互联网上不同的资源。")]),t._v(" "),e("p",[t._v("但是，它并不是我们常说的网址, 网址指的是 URL, 实际上 URI 包含了 URN 和 URL 两个部分，由于 URL 过于普及，就默认将 URI 视为 URL 了。")]),t._v(" "),e("p",[t._v("URI 的结构")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffd677629b70d~tplv-t2oaga2asx-image.image",alt:"image"}})]),t._v(" "),e("p",[t._v("URI 编码")]),t._v(" "),e("p",[t._v("URI 只能使用 ASCII, ASCII 之外的字符是不支持显示的，而且还有一部分符号是界定符，如果不加以处理就会导致解析出错。")]),t._v(" "),e("p",[t._v("因此，URI 引入了编码机制，将所有非 ASCII 码字符和界定符转为十六进制字节值，然后在前面加个%。例如空格被转义成了%20")]),t._v(" "),e("h2",{attrs:{id:"对于定长和不定长的数据-http-是怎么传输的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对于定长和不定长的数据-http-是怎么传输的"}},[t._v("#")]),t._v(" 对于定长和不定长的数据，HTTP 是怎么传输的？")]),t._v(" "),e("p",[t._v("对于定长包体而言，发送端在传输的时候一般会带上 Content-Length, 来指明包体的长度。")]),t._v(" "),e("p",[t._v("对于不定长包体而言利用到另外一个头部字段 Transfer-Encoding: chunked 表示分块传输数据，设置这个字段后会自动产生两个效果:")]),t._v(" "),e("ul",[e("li",[t._v("Content-Length 字段会被忽略")]),t._v(" "),e("li",[t._v("基于长连接持续推送动态内容")])]),t._v(" "),e("h2",{attrs:{id:"http-如何处理大文件的传输"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-如何处理大文件的传输"}},[t._v("#")]),t._v(" HTTP 如何处理大文件的传输？")]),t._v(" "),e("p",[t._v("对于几百 M 甚至上 G 的大文件来说，如果要一口气全部传输过来显然是不现实的，会有大量的等待时间，严重影响用户体验。因此，HTTP 针对这一场景，采取了范围请求的解决方案，允许客户端仅仅请求一个资源的一部分。")]),t._v(" "),e("p",[t._v("当然，前提是服务器要支持范围请求，要支持这个功能，就必须加上这样一个响应头:\nAccept-Ranges: none 用来告知客户端这边是支持范围请求的。")]),t._v(" "),e("p",[t._v("而对于客户端而言，它需要指定请求哪一部分，通过 Range 这个请求头字段确定，格式为 bytes=x-y。接下来就来讨论一下这个 Range 的书写格式:")]),t._v(" "),e("ul",[e("li",[t._v("0-499 表示从开始到第 499 个字节。")]),t._v(" "),e("li",[t._v("500- 表示从第 500 字节到文件终点。")]),t._v(" "),e("li",[t._v("-100 表示文件的最后 100 个字节。")])]),t._v(" "),e("p",[t._v("服务器收到请求之后，首先验证范围是否合法，如果越界了那么返回 416 错误码，否则读取相应片段，返回 206 状态码。同时，服务器需要添加 Content-Range 字段，这个字段的格式根据请求头中 Range 字段的不同而有所差异。具体来说，请求单段数据和请求多段数据，响应头是不一样的。")]),t._v(" "),e("p",[t._v("请求")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 单段数据\nRange: bytes=0-9\n// 多段数据\nRange: bytes=0-9, 30-39\n")])])]),e("p",[t._v("对于单段数据的请求，返回的响应如下:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("HTTP/1.1 206 Partial Content\nContent-Length: 10\nAccept-Ranges: bytes\nContent-Range: bytes 0-9/100\n\ni am xxxxx\n")])])]),e("p",[t._v("Content-Range 字段，0-9 表示请求的返回，100 表示资源的总大小，很好理解。")]),t._v(" "),e("p",[t._v("对于多段数据的请求，返回的响应如下:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("HTTP/1.1 206 Partial Content\nContent-Type: multipart/byteranges; boundary=00000010101\nContent-Length: 189\nConnection: keep-alive\nAccept-Ranges: bytes\n\n\n--00000010101\nContent-Type: text/plain\nContent-Range: bytes 0-9/96\n\ni am xxxxx\n--00000010101\nContent-Type: text/plain\nContent-Range: bytes 20-29/96\n\neex jspy e\n--00000010101--\n")])])]),e("p",[t._v("这个时候出现了一个非常关键的字段 Content-Type: multipart/byteranges;boundary=00000010101，它代表了信息量是这样的:")]),t._v(" "),e("ul",[e("li",[t._v("请求一定是多段数据请求")]),t._v(" "),e("li",[t._v("响应体中的分隔符是 00000010101")])]),t._v(" "),e("p",[t._v("因此，在响应体中各段数据之间会由这里指定的分隔符分开，而且在最后的分隔末尾添上--表示结束。")]),t._v(" "),e("h2",{attrs:{id:"http-中如何处理表单数据的提交"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-中如何处理表单数据的提交"}},[t._v("#")]),t._v(" HTTP 中如何处理表单数据的提交？")]),t._v(" "),e("p",[t._v("在 http 中，有两种主要的表单提交的方式，体现在两种不同的 Content-Type 取值:")]),t._v(" "),e("ul",[e("li",[t._v("application/x-www-form-urlencoded")]),t._v(" "),e("li",[t._v("multipart/form-data")])]),t._v(" "),e("p",[t._v("由于表单提交一般是 POST 请求，很少考虑 GET，因此这里我们将默认提交的数据放在请求体中。")]),t._v(" "),e("p",[t._v("对于 application/x-www-form-urlencoded 格式的表单内容，有以下特点:")]),t._v(" "),e("ul",[e("li",[t._v("其中的数据会被转换成以&分隔的键值对")]),t._v(" "),e("li",[t._v("字符以 URL 编码方式编码。")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('// 转换过程:\n{a: 1, b: 2} -> a=1&b=2\n"a%3D1%26b%3D2"\n')])])]),e("p",[t._v("对于 multipart/form-data 而言:")]),t._v(" "),e("ul",[e("li",[t._v("请求头中的 Content-Type 字段会包含 boundary，且 boundary 的值由浏览器默认指定。例: Content-Type: multipart/form-data;boundary=----WebkitFormBoundaryRRJKeWfHPGrS4LKe。")]),t._v(" "),e("li",[t._v("数据会分为多个部分，每两个部分之间通过分隔符来分隔，每部分表述均有 HTTP 头部描述子包体，如 Content-Type，在最后的分隔符会加上--表示结束。")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('Content-Disposition: form-data;name="data1";\nContent-Type: text/plain\ndata1\n----WebkitFormBoundaryRRJKeWfHPGrS4LKe\nContent-Disposition: form-data;name="data2";\nContent-Type: text/plain\ndata2\n----WebkitFormBoundaryRRJKeWfHPGrS4LKe--\n')])])]),e("h2",{attrs:{id:"http-1-1-有哪些改进"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1-有哪些改进"}},[t._v("#")]),t._v(" HTTP/1.1 有哪些改进")]),t._v(" "),e("p",[t._v("1、增加持久性连接")]),t._v(" "),e("p",[t._v("也就是多个请求和响应可以利用同一个 TCP 连接，而不是每一次请求响应都要新建一个 TCP 连接，减少了建立和关闭连接的消耗和延迟。")]),t._v(" "),e("p",[t._v("2、增加管道机制")]),t._v(" "),e("p",[t._v("增加了管道机制，请求可以同时发出，但是响应必须按照请求发出的顺序依次返回，性能在一定程度上得到了改善。")]),t._v(" "),e("p",[t._v("3、分块传输")]),t._v(" "),e("p",[t._v("在 HTTP/1.1 版本中，可以不必等待数据完全处理完毕再返回，服务器产生部分数据，那么就发送部分数据，很明此种方式更加优秀一些，可以节省很多等待时间。")]),t._v(" "),e("p",[t._v("4、范围请求")]),t._v(" "),e("p",[t._v("HTTP/1.1 中在请求消息中引入了 range 头域，它允许只请求资源的某个部分。")]),t._v(" "),e("p",[t._v("5、增加 host 字段")]),t._v(" "),e("p",[t._v("使得一个服务器能够用来创建多个 Web 站点。")]),t._v(" "),e("h2",{attrs:{id:"http1-1-如何解决-http-的队头阻塞问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http1-1-如何解决-http-的队头阻塞问题"}},[t._v("#")]),t._v(" HTTP1.1 如何解决 HTTP 的队头阻塞问题？")]),t._v(" "),e("p",[t._v("使用并发连接和域名分片")]),t._v(" "),e("h3",{attrs:{id:"什么是-http-队头阻塞"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是-http-队头阻塞"}},[t._v("#")]),t._v(" 什么是 HTTP 队头阻塞？")]),t._v(" "),e("p",[t._v("从前面的小节可以知道，HTTP 传输是基于请求-应答的模式进行的，报文必须是一发一收，但值得注意的是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是著名的 HTTP 队头阻塞问题。")]),t._v(" "),e("h3",{attrs:{id:"并发连接"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#并发连接"}},[t._v("#")]),t._v(" 并发连接")]),t._v(" "),e("p",[t._v("对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在 RFC2616 规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个。\n但其实，即使是提高了并发连接，还是不能满足人们对性能的需求。")]),t._v(" "),e("h3",{attrs:{id:"域名分片"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#域名分片"}},[t._v("#")]),t._v(" 域名分片")]),t._v(" "),e("p",[t._v("一个域名不是可以并发 6 个长连接吗？那我就多分几个域名。\n比如 content1.sanyuan.com 、content2.sanyuan.com。\n这样一个 sanyuan.com 域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。")]),t._v(" "),e("h2",{attrs:{id:"http-2-有哪些改进"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-2-有哪些改进"}},[t._v("#")]),t._v(" HTTP/2 有哪些改进？")]),t._v(" "),e("p",[t._v("1、头部压缩")]),t._v(" "),e("p",[t._v("客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。")]),t._v(" "),e("p",[t._v("2、二进制传输")]),t._v(" "),e("p",[t._v("首先，HTTP/2 认为明文传输对机器而言太麻烦了，不方便计算机的解析，因为对于文本而言会有多义性的字符，比如回车换行到底是内容还是分隔符，在内部需要用到状态机去识别，效率比较低。于是 HTTP/2 干脆把报文全部换成二进制格式，全部传输 01 串，方便了机器的解析。")]),t._v(" "),e("p",[t._v("原来 Headers + Body 的报文格式如今被拆分成了一个个二进制的帧，用 Headers 帧存放头部字段，Data 帧存放请求体数据。分帧之后，服务器看到的不再是一个个完整的 HTTP 请求报文，而是一堆乱序的二进制帧。这些二进制帧不存在先后关系，因此也就不会排队等待，也就没有了 HTTP 的队头阻塞问题。")]),t._v(" "),e("p",[t._v("3、多路复用")]),t._v(" "),e("p",[t._v("通信双方都可以给对方发送二进制帧，这种二进制帧的双向传输的序列，也叫做流(Stream)。HTTP/2 用流来在一个 TCP 连接上来进行多个数据帧的通信，这就是多路复用的概念。")]),t._v(" "),e("p",[t._v("首先要声明的是，所谓的乱序，指的是不同 ID 的 Stream 是乱序的，但同一个 Stream ID 的帧一定是按顺序传输的。二进制帧到达后对方会将 Stream ID 相同的二进制帧组装成完整的请求报文和响应报文。当然，在二进制帧当中还有其他的一些字段，实现了优先级和流量控制等功能。")]),t._v(" "),e("p",[t._v("4、服务器推送")]),t._v(" "),e("p",[t._v("外值得一说的是 HTTP/2 的服务器推送(Server Push)。在 HTTP/2 当中，服务器已经不再是完全被动地接收请求，响应请求，它也能新建 stream 来给客户端发送消息，当 TCP 连接建立之后，比如浏览器请求一个 HTML 文件，服务器就可以在返回 HTML 的基础上，将 HTML 中引用到的其他资源文件一起返回给客户端，减少客户端的等待。")]),t._v(" "),e("h2",{attrs:{id:"请简单介绍一下-lru-least-recently-used-算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#请简单介绍一下-lru-least-recently-used-算法"}},[t._v("#")]),t._v(" 请简单介绍一下 LRU （Least recently used）算法")]),t._v(" "),e("p",[t._v("LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。")]),t._v(" "),e("ol",[e("li",[t._v("新数据插入到链表头部；")]),t._v(" "),e("li",[t._v("每当缓存命中（即缓存数据被访问），则将数据移到链表头部；")]),t._v(" "),e("li",[t._v("当链表满的时候，将链表尾部的数据丢弃。")])])])}),[],!1,null,null,null);a.default=n.exports}}]);