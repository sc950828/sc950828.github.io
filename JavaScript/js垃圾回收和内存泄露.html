<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>简介 | 苏纯的博客</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/randy.jpg">
    <meta name="description" content="苏纯,汨罗苏纯,苏纯的博客,苏纯的前端博客,苏纯的个人博客,前端开发">
    <meta name="keywords" content="苏纯,苏纯的博客,苏纯的个人博客,苏纯的前端博客,前端博客,前端个人博客,前端开发">
    
    <link rel="preload" href="/assets/css/0.styles.22fcb12a.css" as="style"><link rel="preload" href="/assets/js/app.9f47291f.js" as="script"><link rel="preload" href="/assets/js/2.3fe5eade.js" as="script"><link rel="preload" href="/assets/js/24.85aedd8a.js" as="script"><link rel="prefetch" href="/assets/js/10.f9319f1a.js"><link rel="prefetch" href="/assets/js/11.7c8892d0.js"><link rel="prefetch" href="/assets/js/12.bfd4ae56.js"><link rel="prefetch" href="/assets/js/13.12bdab88.js"><link rel="prefetch" href="/assets/js/14.b56cbcee.js"><link rel="prefetch" href="/assets/js/15.f176549c.js"><link rel="prefetch" href="/assets/js/16.8d9aa7cb.js"><link rel="prefetch" href="/assets/js/17.f91940a4.js"><link rel="prefetch" href="/assets/js/18.380e1d86.js"><link rel="prefetch" href="/assets/js/19.09bf99ef.js"><link rel="prefetch" href="/assets/js/20.7b9e2c8d.js"><link rel="prefetch" href="/assets/js/21.3c129053.js"><link rel="prefetch" href="/assets/js/22.9390abbb.js"><link rel="prefetch" href="/assets/js/23.051467ca.js"><link rel="prefetch" href="/assets/js/25.a3b61af0.js"><link rel="prefetch" href="/assets/js/26.ff1c92fd.js"><link rel="prefetch" href="/assets/js/27.396c5348.js"><link rel="prefetch" href="/assets/js/28.e3e4164c.js"><link rel="prefetch" href="/assets/js/29.e69ccd94.js"><link rel="prefetch" href="/assets/js/3.11c80b4e.js"><link rel="prefetch" href="/assets/js/30.28a3997f.js"><link rel="prefetch" href="/assets/js/31.e54ed449.js"><link rel="prefetch" href="/assets/js/32.eb4f0da3.js"><link rel="prefetch" href="/assets/js/33.a05772c0.js"><link rel="prefetch" href="/assets/js/34.c74e9e53.js"><link rel="prefetch" href="/assets/js/35.4aff9555.js"><link rel="prefetch" href="/assets/js/36.c743e87e.js"><link rel="prefetch" href="/assets/js/4.9e16ce31.js"><link rel="prefetch" href="/assets/js/5.126b2f5e.js"><link rel="prefetch" href="/assets/js/6.b325cee5.js"><link rel="prefetch" href="/assets/js/7.57646205.js"><link rel="prefetch" href="/assets/js/8.da82a32b.js"><link rel="prefetch" href="/assets/js/9.2337a7ce.js">
    <link rel="stylesheet" href="/assets/css/0.styles.22fcb12a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">苏纯的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/guide.html" class="nav-link">
  导航
</a></div><div class="nav-item"><a href="https://juejin.cn/user/3403743730867767/posts" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/guide.html" class="nav-link">
  导航
</a></div><div class="nav-item"><a href="https://juejin.cn/user/3403743730867767/posts" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><a href="/HTML" class="sidebar-heading clickable"><span>HTML</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/CSS" class="sidebar-heading clickable"><span>CSS</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/JavaScript" class="sidebar-heading clickable router-link-active open"><span>JavaScript</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/JavaScript/前端二进制一次性搞清楚.html" class="sidebar-link">前端二进制一次性搞清楚</a></li><li><a href="/JavaScript/都2022年了你不会还没搞懂JS数据类型吧.html" class="sidebar-link">都2022年了你不会还没搞懂JS数据类型吧</a></li><li><a href="/JavaScript/都2022年了你不会还没搞懂JS原型和继承吧.html" class="sidebar-link">都2022年了你不会还没搞懂JS原型和继承吧</a></li><li><a href="/JavaScript/都2022年了你不会还没搞懂JS赋值拷贝、浅拷贝、深拷贝吧.html" class="sidebar-link">都2022年了你不会还没搞懂JS赋值拷贝、浅拷贝、深拷贝吧</a></li><li><a href="/JavaScript/都2022年了你不会还没搞懂对象数组的遍历吧.html" class="sidebar-link">都2022年了你不会还没搞懂对象数组的遍历吧</a></li><li><a href="/JavaScript/都2022年了你不会还没搞懂this吧.html" class="sidebar-link">都2022年了你不会还没搞懂this吧</a></li><li><a href="/JavaScript/JSObjectAPI详解.html" class="sidebar-link">JS Object API详解</a></li><li><a href="/JavaScript/前端文件的上传和下载.html" class="sidebar-link">前端文件的上传和下载</a></li><li><a href="/JavaScript/js垃圾回收和内存泄露.html" class="active sidebar-link">js垃圾回收和内存泄露</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/JavaScript/js垃圾回收和内存泄露.html#简介" class="sidebar-link">简介</a></li><li class="sidebar-sub-header"><a href="/JavaScript/js垃圾回收和内存泄露.html#什么是垃圾回收" class="sidebar-link">什么是垃圾回收</a></li><li class="sidebar-sub-header"><a href="/JavaScript/js垃圾回收和内存泄露.html#垃圾是怎么产生的又如何判断垃圾" class="sidebar-link">垃圾是怎么产生的又如何判断垃圾</a></li><li class="sidebar-sub-header"><a href="/JavaScript/js垃圾回收和内存泄露.html#为什么要垃圾回收" class="sidebar-link">为什么要垃圾回收</a></li><li class="sidebar-sub-header"><a href="/JavaScript/js垃圾回收和内存泄露.html#垃圾回收策略" class="sidebar-link">垃圾回收策略</a></li><li class="sidebar-sub-header"><a href="/JavaScript/js垃圾回收和内存泄露.html#v8-引擎的垃圾回收" class="sidebar-link">v8 引擎的垃圾回收</a></li><li class="sidebar-sub-header"><a href="/JavaScript/js垃圾回收和内存泄露.html#内存泄露" class="sidebar-link">内存泄露</a></li><li class="sidebar-sub-header"><a href="/JavaScript/js垃圾回收和内存泄露.html#参考文章" class="sidebar-link">参考文章</a></li><li class="sidebar-sub-header"><a href="/JavaScript/js垃圾回收和内存泄露.html#后记" class="sidebar-link">后记</a></li></ul></li><li><a href="/JavaScript/js执行上下文和执行机制一文说透.html" class="sidebar-link">js执行上下文和执行机制一文说透</a></li><li><a href="/JavaScript/js中关于事件的那些事一次性搞懂.html" class="sidebar-link">js中关于事件的那些事一次性搞懂</a></li><li><a href="/JavaScript/js异步编程.html" class="sidebar-link">js异步编程</a></li><li><a href="/JavaScript/节流、防抖一套带走.html" class="sidebar-link">节流、防抖一套带走</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/ECMAScript" class="sidebar-heading clickable"><span>ECMAScript</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/H5" class="sidebar-heading clickable"><span>H5</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="简介"><a href="#简介" class="header-anchor">#</a> 简介</h2> <p>本文主要介绍 js 中垃圾回收策略以及谷歌 v8 引擎在垃圾回收上的优化和常见的一些会导致内存泄露操作，希望能对你们有所帮助。</p> <h2 id="什么是垃圾回收"><a href="#什么是垃圾回收" class="header-anchor">#</a> 什么是垃圾回收</h2> <p><code>GC</code> 即 <code>Garbage Collection（垃圾回收）</code> ，我们的程序在工作过程中会产生很多 <code>垃圾</code>，这些垃圾是程序不用的内存或者是之前用过了，以后不会再用的内存空间，而 <code>GC</code> 就是负责自动回收这些垃圾，这就是我们常说的 <code>垃圾回收机制</code> 。</p> <p>当然也不是所有语言都有 <code>GC</code>，一般的高级语言里面会自带 <code>GC</code>，比如 <code>Java、Python、JavaScript</code> 等，也有无 <code>GC</code> 的语言，比如 <code>C、C++</code> 等，那这种就需要我们程序员手动管理内存了，相对比较麻烦。</p> <h2 id="垃圾是怎么产生的又如何判断垃圾"><a href="#垃圾是怎么产生的又如何判断垃圾" class="header-anchor">#</a> 垃圾是怎么产生的又如何判断垃圾</h2> <p>简单来说垃圾就是程序不用的内存或者是之前用过了，以后不会再用的内存空间。</p> <blockquote><p>如何判断垃圾就是看这个对象能否被访问，那如何知道对象能否被访问？有一个专业的词叫<strong>可达性</strong>。根据对象是否可达来判断。可达就不需要被回收，不可达就需要被回收。</p></blockquote> <p>我简单举个例子</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> test <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&quot;randy&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

test <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>前面笔者介绍<a href="https://juejin.cn/post/7063670330539114503" target="_blank" rel="noopener noreferrer">js 数据类型<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的时候就说过，在 js 中数据分基本数据类型和引用数据类型，引用数据类型在栈中保存的是引用，实际是存储在堆中的。</p> <p>在上面的例子中我们首先创建了一个<code>test</code>变量指向对象<code>{name: 'randy'}</code>，然后又把<code>test</code>指向了新的数组<code>[1, 2, 3]</code>，所以之前的<code>{name: 'randy'}</code>就不可能被访问到了(没有了可达性)，就变成了垃圾。</p> <h2 id="为什么要垃圾回收"><a href="#为什么要垃圾回收" class="header-anchor">#</a> 为什么要垃圾回收</h2> <p>从上面的例子可以看出产生了垃圾就会导致浪费内存空间，一个两个还好，多了的话我们的程序可能会越来越卡顿，到最后崩溃。</p> <p>所以就需要垃圾回收机制来帮我们自动清理没用的垃圾，释放出更多的内存来给当前程序使用，这样程序就会一直流畅的运行下去。</p> <h2 id="垃圾回收策略"><a href="#垃圾回收策略" class="header-anchor">#</a> 垃圾回收策略</h2> <p>垃圾回收策略里面最常用的两个策略就是<code>标记清除法</code>和<code>引用计数法</code>。</p> <h3 id="标记清除法"><a href="#标记清除法" class="header-anchor">#</a> 标记清除法</h3> <p>标记清除（Mark-Sweep），目前在 <code>JavaScript引擎</code> 里这种算法是最常用的，到目前为止的大多数浏览器的 <code>JavaScript引擎</code> 都在采用标记清除算法，只是各大浏览器厂商还对此算法进行了优化加工，且不同浏览器的 <code>JavaScript引擎</code> 在运行垃圾回收的频率上有所差异。</p> <p>就像它的名字一样，此算法分为 <code>标记</code> 和 <code>清除</code> 两个阶段，标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁。</p> <p>引擎在使用标记清除算法时，需要从出发点去遍历内存中所有的对象去打标记，而这个出发点有很多，我们称之为一组  <code>根</code>  对象，而所谓的根对象，其实在浏览器环境中包括又不止于  <code>全局Window对象</code>、<code>文档DOM树</code>  等。</p> <h4 id="标记清除过程"><a href="#标记清除过程" class="header-anchor">#</a> 标记清除过程</h4> <p>整个标记清除算法大致过程如下</p> <ol><li>垃圾收集器在运行时会给内存中的所有变量都加上一个标记。</li> <li>然后从各个根对象开始遍历，把可达的变量的标记清除掉。</li> <li>此后，依然有标记的变量就被视为准备删除的变量，清理所有还有标记垃圾，销毁并回收它们所占用的内存空间。</li></ol> <h4 id="标记清除优点"><a href="#标记清除优点" class="header-anchor">#</a> 标记清除优点</h4> <p>标记清除算法实现比较简单，打标记也无非打与不打两种情况。而且执行效率高。</p> <h4 id="标记清除缺点"><a href="#标记清除缺点" class="header-anchor">#</a> 标记清除缺点</h4> <p>标记清除算法在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了  <code>内存碎片</code>（如下图），并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12247ac3d8f249a5ab85b9b40ba1147b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt=""></p> <p>假设我们新建对象分配内存时需要大小为  <code>size</code>，由于空闲内存是间断的、不连续的，则需要对空闲内存列表进行一次单向遍历找出大于等于  <code>size</code>  的块才能为其分配（如下图）</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb5107f04a3249ce8d37ec7cc5fd9668~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt=""></p> <p>那如何找到合适的块呢？我们可以采取下面三种分配策略</p> <ul><li><code>First-fit</code>，找到大于等于 <code>size</code> 的块立即返回</li> <li><code>Best-fit</code>，遍历整个空闲列表，返回大于等于 <code>size</code> 的最小分块</li> <li><code>Worst-fit</code>，遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 <code>size</code> 大小，并将该部分返回</li></ul> <p>这三种策略里面 <code>Worst-fit</code> 的空间利用率看起来是最合理，但实际上切分之后会造成更多的小块，形成内存碎片，所以不推荐使用，对于 <code>First-fit</code> 和 <code>Best-fit</code> 来说，考虑到分配的速度和效率 <code>First-fit</code> 是更为明智的选择</p> <p>综上所述，标记清除算法或者说策略就有两个很明显的缺点</p> <ul><li><strong>内存碎片化</strong>，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块。</li> <li><strong>分配速度慢</strong>，因为即便是使用 <code>First-fit</code> 策略，其操作仍是一个 <code>O(n)</code> 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢。</li></ul> <h3 id="引用计数法"><a href="#引用计数法" class="header-anchor">#</a> 引用计数法</h3> <p>引用计数（Reference Counting），这其实是早先的一种垃圾回收算法，它把 <code>对象是否不再需要</code> 简化定义为 <code>对象有没有其他对象引用到它</code>，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收，目前很少使用这种算法了，因为它的问题很多。</p> <h4 id="引用计数法过程"><a href="#引用计数法过程" class="header-anchor">#</a> 引用计数法过程</h4> <p>引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。</p> <p>如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量改变了引用对象，则该值引用次数减 1。</p> <p>当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。</p> <p>这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为 0 的值所占用的内存。</p> <p>下面看个例子</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> name1 <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&quot;randy&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//count==1</span>
<span class="token keyword">let</span> name2 <span class="token operator">=</span> name1<span class="token punctuation">;</span> <span class="token comment">//count==2</span>
b <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">//count==1</span>
a <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">//count==0 被清除</span>
</code></pre></div><h4 id="引用计数法优点"><a href="#引用计数法优点" class="header-anchor">#</a> 引用计数法优点</h4> <p>引用计数在引用值为 0 时，也就是在变成垃圾的那一刻就会被回收，所以它可以立即回收垃圾。而标记清除算法需要每隔一段时间进行一次，在应用程序运行过程中线程就必须要暂停去执行一次 <code>GC</code>。</p> <p>另外，标记清除算法需要遍历堆里的活动以及非活动对象来清除，而引用计数则只需要在引用时计数值为 0 的时候清除就可以了。</p> <h4 id="引用计数法缺点"><a href="#引用计数法缺点" class="header-anchor">#</a> 引用计数法缺点</h4> <p>首先每个引用变量它都需要一个计数器，因此计数器需要占很大的位置。</p> <p>还有就是无法解决循环引用无法回收的问题。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">cycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  obj1<span class="token punctuation">.</span>a <span class="token operator">=</span> obj2<span class="token punctuation">;</span>
  obj2<span class="token punctuation">.</span>a <span class="token operator">=</span> obj1<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">cycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>上面代码中<code>cycle</code>函数执行完后不需要了，所以<code>o1</code>和<code>o2</code>的内存应该被释放，但是他们互相引用导致内存不会被回收，这就是循环引用。</p> <h2 id="v8-引擎的垃圾回收"><a href="#v8-引擎的垃圾回收" class="header-anchor">#</a> v8 引擎的垃圾回收</h2> <p>v8 引擎对垃圾回收做了更近一步的优化。使用分代式垃圾回收机制，把对象分为新生代和老生代两种类型。对这两部分采用不同的垃圾回收策略。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abae5b06648a40d2aaa453b5d8a83939~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt=""></p> <p>新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。</p> <h3 id="分代内存"><a href="#分代内存" class="header-anchor">#</a> 分代内存</h3> <p>默认情况下，32 位系统新生代内存大小为 16MB，老生代内存大小为 700MB，64 位系统下，新生代内存大小为 32MB，老生代内存大小为 1.4GB。</p> <p>新生代平均分成两块相等的内存空间，叫做<code>semispace</code>，每块内存大小 8MB（32 位）或 16MB（64 位）。</p> <h3 id="新生代垃圾回收"><a href="#新生代垃圾回收" class="header-anchor">#</a> 新生代垃圾回收</h3> <p>新生代对象是通过一个名为  <code>Scavenge</code>  的算法进行垃圾回收，在  <code>Scavenge算法</code>  的具体实现中，主要采用了一种复制式的方法即  <code>Cheney算法</code>。</p> <p><code>Cheney算法</code>将堆内存一分为二，一个是处于使用状态的空间我们暂且称之为  <code>使用区</code>，一个是处于闲置状态的空间我们称之为  <code>空闲区</code>。</p> <p>新加入的对象最开始都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作。</p> <p>当开始进行垃圾回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成之后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区。</p> <blockquote><p>为什么要把使用区和空闲区进行对调呢？就是为了让新加入的对象最开始都存放到使用区，空闲区始终保持空闲的状态。</p></blockquote> <p>因为新生代中对象的生命周期较短，并且<code>Scavenge</code>由于只复制存活的对象，所以它在时间效率上有优异的体现。
由于<code>Scavenge</code>将堆内存一分为二，所以永远最多使用一半的内存，所以内存利用率不高。</p> <h3 id="晋升"><a href="#晋升" class="header-anchor">#</a> 晋升</h3> <p>对象从新生代移动到老生代的过程叫作晋升。</p> <p>对象晋升的条件主要有两个：</p> <ol><li><p>对象从使用区复制到空闲区时，会检查它的内存地址来判断这个对象是否已经经历过一次<code>Scavenge</code>回收。如果已经经历过了，则会将该对象从使用区直接移动到老生代中，如果没有，则复制到空闲区。<strong>总结来说，如果一个对象是第二次经历从使用区复制到空闲区，那么这个对象会被直接移动到老生代中</strong>。</p></li> <li><p>当要从使用区复制一个对象到空闲区时，如果空闲区已经使用了超过<code>25%</code>，则这个对象会直接晋升到老生代中。设置<code>25%</code>这个阈值的原因是当这次<code>Scavenge</code>回收完成后，这个空闲区会变为使用区，接下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配。</p></li></ol> <h3 id="老生代垃圾回收"><a href="#老生代垃圾回收" class="header-anchor">#</a> 老生代垃圾回收</h3> <p>在老生代中，存活对象占较大比重，如果继续采用<code>Scavenge</code>算法进行管理，就会存在两个问题：</p> <ol><li>由于存活对象较多，复制存活对象的效率会很低。</li> <li>采用<code>Scavenge</code>算法会浪费一半内存，由于老生代所占堆内存远大于新生代，所以浪费会很严重。</li></ol> <p>所以，V8 在老生代中主要采用了<strong>Mark-Sweep</strong>和<strong>Mark-Compact</strong>相结合的方式进行垃圾回收。</p> <p><code>Mark-Sweep</code>是标记清除的意思，就是我们前面介绍的标记清除垃圾回收。前面我们说到标记清除会有<code>内存碎片化</code>和<code>分配速度慢</code>问题。所以就有了下面的<code>Mark-Compact</code>。</p> <p><code>Mark-Compact</code>就是标记整理的意思。标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，这样存活的对象在内存空间中是连续的，就不会再有内存碎片这种问题了。</p> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p>v8 引擎中的分代式机制把一些新、小、存活时间短的对象作为新生代，采用<code>Scavenge</code> 算法进行快速清理，而一些大、老、存活时间长的对象作为老生代，采用了<code>Mark-Sweep</code>和<code>Mark-Compact</code>相结合的方式进行垃圾回收，可以说此机制大大提高了垃圾回收机制的效率。</p> <h2 id="内存泄露"><a href="#内存泄露" class="header-anchor">#</a> 内存泄露</h2> <p>虽然引擎有优化，但并不是说我们就可以完全不用关心垃圾回收这块了，我们的代码中依然要主动避免一些不利于引擎做垃圾回收操作，因为不是所有无用对象内存都可以被垃圾回收机制回收的，那当不再用到的内存，没有及时回收时，我们叫它  <code>内存泄漏</code>。</p> <p>下面我们来说说常见的内存泄露情况。</p> <h3 id="不正当的闭包"><a href="#不正当的闭包" class="header-anchor">#</a> 不正当的闭包</h3> <p>闭包在不同的文献中有不同的定义，笔者理解的闭包是在一个函数中返回了另外一个新函数，这个新函数使用了外部函数的局部变量。</p> <p>举个例子</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">&quot;randy&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> newSay <span class="token operator">=</span> <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">newSay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>上面的<code>say</code>方法返回了一个新的函数，这个函数使用了外部函数的局部变量<code>name</code>，所以就产生了闭包。这里的<code>name</code>变量内存就不会被释放，就会导致内存泄露。</p> <p>那怎么解决呢？</p> <p>我们只需要在调用完毕该方法后把变量置为<code>null</code>就可以啦。</p> <div class="language-js extra-class"><pre class="language-js"><code>newSay <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="意外的全局变量"><a href="#意外的全局变量" class="header-anchor">#</a> 意外的全局变量</h3> <p>函数中的局部变量在函数执行结束后这些变量已经不再被需要，所以垃圾回收器会识别并释放它们。但是对于全局变量，垃圾回收器很难判断这些变量什么时候才不被需要，所以全局变量通常不会被回收，我们使用全局变量是没问题的，但同时我们要避免一些额外的全局变量产生。</p> <p>我们再来看看下面的例子</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 没有声明从而制造了隐式全局变量test1</span>
  test1 <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&quot;randy&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">// 函数内部this指向window，制造了隐式全局变量test2</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>test2 <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&quot;randy2&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="游离-dom-引用"><a href="#游离-dom-引用" class="header-anchor">#</a> 游离 DOM 引用</h3> <p>我们在平时的开发中进行 <code>DOM</code> 操作时会使用变量缓存 <code>DOM</code> 节点的引用，但移除节点的时候，我们应该同步释放缓存的引用，否则游离的子树无法释放。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> root <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&quot;#root&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> div1 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&quot;#div1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

root<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>div1<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>一定要将<code>DOM</code>变量置为<code>null</code>，这样才会被垃圾回收机制回收。</p> <div class="language-js extra-class"><pre class="language-js"><code>div1 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="未清理的定时器"><a href="#未清理的定时器" class="header-anchor">#</a> 未清理的定时器</h3> <p>在我们平时的开发中可能会使用到<code>setTimeout</code>  和  <code>setInterval</code>，但是在每次使用完毕后你们有没有将定时器清除呢？如果没有清除的话也会造成内存泄漏。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;randy&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> inter <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;randy&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在使用完毕后我们一定要将其清除</p> <div class="language-js extra-class"><pre class="language-js"><code>timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
inter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre></div><p>说到这里对于浏览器中的  <code>requestAnimationFrame</code>  也存在这个问题，我们需要在不需要的时候用  <code>cancelAnimationFrame</code>  来取消使用。</p> <h3 id="未清理的事件监听器"><a href="#未清理的事件监听器" class="header-anchor">#</a> 未清理的事件监听器</h3> <p>在我们平时的开发中可能会使用到<code>addEventListener</code>来进行事件的监听，但是监听完毕后有没有使用<code>removeEventListener</code>进行清除呢。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;randy&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;resize&quot;</span><span class="token punctuation">,</span> say<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>一定要记得在使用完毕后使用<code>removeEventListener</code>进行清除。</p> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;resize&quot;</span><span class="token punctuation">,</span> say<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在<code>vue</code>中还有我们常使用的<code>eventBus</code>进行事件传播。</p> <div class="language-js extra-class"><pre class="language-js"><code>eventBus<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;say&quot;</span><span class="token punctuation">,</span> say<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>我们一定要记得<code>off</code>方法进行清除。</p> <div class="language-js extra-class"><pre class="language-js"><code>eventBus<span class="token punctuation">.</span><span class="token function">off</span><span class="token punctuation">(</span><span class="token string">&quot;say&quot;</span><span class="token punctuation">,</span> say<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="未清理的-console"><a href="#未清理的-console" class="header-anchor">#</a> 未清理的 console</h3> <p>什么<code>console</code>也会造成内存泄露？</p> <p>我们之所以在控制台能看到数据输出，是因为浏览器保存了我们输出对象的信息数据引用，也正是因此未清理的  <code>console</code>  如果输出了对象也会造成内存泄漏。</p> <p>所以在上到生产环境的时候我们一般都会使用<a href="https://github.com/Riokai/babel-plugin-transform-remove-console" target="_blank" rel="noopener noreferrer">插件<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>把<code>console</code>进行清除。</p> <h3 id="未清理的-map-set"><a href="#未清理的-map-set" class="header-anchor">#</a> 未清理的 Map Set</h3> <p>由于<code>ES</code>普及，我们可能会用得到<code>ES6</code>的<code>Map</code>和<code>Set</code>。<code>Map</code>和<code>Set</code>和<code>Object</code>一样都是强引用，也就是如果对象保存在<code>Map</code>和<code>Set</code>中是不会被垃圾回收机制回收的。</p> <p>所以就有了<code>WeakSet</code>和<code>WeakMap</code>，保存这两个对象里对象是弱引用，一个对象若只被弱引用所引用，则被认为是不可访问（或弱可访问）的，因此可能在任何时刻被回收，不会干扰垃圾回收机制的进行。</p> <p>简单来说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 <code>WeakSet</code>或<code>WeakMap</code> 之中。</p> <h2 id="参考文章"><a href="#参考文章" class="header-anchor">#</a> 参考文章</h2> <p><a href="https://juejin.cn/post/6981588276356317214" target="_blank" rel="noopener noreferrer">你真的了解垃圾回收机制吗<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.cn/post/6844903591510016007" target="_blank" rel="noopener noreferrer">聊聊 V8 引擎的垃圾回收<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.cn/post/6984188410659340324" target="_blank" rel="noopener noreferrer">你的程序中可能存在内存泄漏<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="后记"><a href="#后记" class="header-anchor">#</a> 后记</h2> <p>本文为笔者个人学习笔记，如有谬误，还请告知，万分感谢！如果本文对你有所帮助，还请点个关注点个赞~，您的支持是笔者不断更新的动力。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/JavaScript/前端文件的上传和下载.html" class="prev">
        前端文件的上传和下载
      </a></span> <span class="next"><a href="/JavaScript/js执行上下文和执行机制一文说透.html">
        js执行上下文和执行机制一文说透
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.9f47291f.js" defer></script><script src="/assets/js/2.3fe5eade.js" defer></script><script src="/assets/js/24.85aedd8a.js" defer></script>
  </body>
</html>
